// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/action"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/appconfig"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/competition"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/competitionresult"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/fcmtoken"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/goal"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/invite"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/notification"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/notificationpreferences"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/post"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/predicate"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/profile"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/squad"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/user"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/workout"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/workoutdata"
	"github.com/jacobmaizel/swiftui-golang-app-demo/ent/workoutroutedata"
	"github.com/jacobmaizel/swiftui-golang-app-demo/shared"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAction                  = "Action"
	TypeAppConfig               = "AppConfig"
	TypeCompetition             = "Competition"
	TypeCompetitionResult       = "CompetitionResult"
	TypeFcmToken                = "FcmToken"
	TypeGoal                    = "Goal"
	TypeInvite                  = "Invite"
	TypeNotification            = "Notification"
	TypeNotificationPreferences = "NotificationPreferences"
	TypePost                    = "Post"
	TypeProfile                 = "Profile"
	TypeSquad                   = "Squad"
	TypeUser                    = "User"
	TypeWorkout                 = "Workout"
	TypeWorkoutData             = "WorkoutData"
	TypeWorkoutRouteData        = "WorkoutRouteData"
)

// ActionMutation represents an operation that mutates the Action nodes in the graph.
type ActionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	title         *string
	clearedFields map[string]struct{}
	sender        *uuid.UUID
	clearedsender bool
	done          bool
	oldValue      func(context.Context) (*Action, error)
	predicates    []predicate.Action
}

var _ ent.Mutation = (*ActionMutation)(nil)

// actionOption allows management of the mutation configuration using functional options.
type actionOption func(*ActionMutation)

// newActionMutation creates new mutation for the Action entity.
func newActionMutation(c config, op Op, opts ...actionOption) *ActionMutation {
	m := &ActionMutation{
		config:        c,
		op:            op,
		typ:           TypeAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActionID sets the ID field of the mutation.
func withActionID(id uuid.UUID) actionOption {
	return func(m *ActionMutation) {
		var (
			err   error
			once  sync.Once
			value *Action
		)
		m.oldValue = func(ctx context.Context) (*Action, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Action.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAction sets the old Action of the mutation.
func withAction(node *Action) actionOption {
	return func(m *ActionMutation) {
		m.oldValue = func(context.Context) (*Action, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Action entities.
func (m *ActionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Action.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ActionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Action entity.
// If the Action object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActionMutation) ResetTitle() {
	m.title = nil
}

// SetSenderID sets the "sender" edge to the Profile entity by id.
func (m *ActionMutation) SetSenderID(id uuid.UUID) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the Profile entity.
func (m *ActionMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the Profile entity was cleared.
func (m *ActionMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *ActionMutation) SenderID() (id uuid.UUID, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *ActionMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *ActionMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// Where appends a list predicates to the ActionMutation builder.
func (m *ActionMutation) Where(ps ...predicate.Action) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Action, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Action).
func (m *ActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, action.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, action.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, action.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case action.FieldCreatedAt:
		return m.CreatedAt()
	case action.FieldUpdatedAt:
		return m.UpdatedAt()
	case action.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case action.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case action.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case action.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Action field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case action.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case action.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case action.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Action numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Action nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActionMutation) ResetField(name string) error {
	switch name {
	case action.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case action.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case action.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Action field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sender != nil {
		edges = append(edges, action.EdgeSender)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case action.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsender {
		edges = append(edges, action.EdgeSender)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActionMutation) EdgeCleared(name string) bool {
	switch name {
	case action.EdgeSender:
		return m.clearedsender
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActionMutation) ClearEdge(name string) error {
	switch name {
	case action.EdgeSender:
		m.ClearSender()
		return nil
	}
	return fmt.Errorf("unknown Action unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActionMutation) ResetEdge(name string) error {
	switch name {
	case action.EdgeSender:
		m.ResetSender()
		return nil
	}
	return fmt.Errorf("unknown Action edge %s", name)
}

// AppConfigMutation represents an operation that mutates the AppConfig nodes in the graph.
type AppConfigMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	auto_sync_workouts *bool
	clearedFields      map[string]struct{}
	profile            *uuid.UUID
	clearedprofile     bool
	done               bool
	oldValue           func(context.Context) (*AppConfig, error)
	predicates         []predicate.AppConfig
}

var _ ent.Mutation = (*AppConfigMutation)(nil)

// appconfigOption allows management of the mutation configuration using functional options.
type appconfigOption func(*AppConfigMutation)

// newAppConfigMutation creates new mutation for the AppConfig entity.
func newAppConfigMutation(c config, op Op, opts ...appconfigOption) *AppConfigMutation {
	m := &AppConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeAppConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppConfigID sets the ID field of the mutation.
func withAppConfigID(id uuid.UUID) appconfigOption {
	return func(m *AppConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *AppConfig
		)
		m.oldValue = func(ctx context.Context) (*AppConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppConfig sets the old AppConfig of the mutation.
func withAppConfig(node *AppConfig) appconfigOption {
	return func(m *AppConfigMutation) {
		m.oldValue = func(context.Context) (*AppConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppConfig entities.
func (m *AppConfigMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppConfigMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppConfigMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAutoSyncWorkouts sets the "auto_sync_workouts" field.
func (m *AppConfigMutation) SetAutoSyncWorkouts(b bool) {
	m.auto_sync_workouts = &b
}

// AutoSyncWorkouts returns the value of the "auto_sync_workouts" field in the mutation.
func (m *AppConfigMutation) AutoSyncWorkouts() (r bool, exists bool) {
	v := m.auto_sync_workouts
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSyncWorkouts returns the old "auto_sync_workouts" field's value of the AppConfig entity.
// If the AppConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigMutation) OldAutoSyncWorkouts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSyncWorkouts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSyncWorkouts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSyncWorkouts: %w", err)
	}
	return oldValue.AutoSyncWorkouts, nil
}

// ResetAutoSyncWorkouts resets all changes to the "auto_sync_workouts" field.
func (m *AppConfigMutation) ResetAutoSyncWorkouts() {
	m.auto_sync_workouts = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *AppConfigMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *AppConfigMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *AppConfigMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *AppConfigMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *AppConfigMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *AppConfigMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the AppConfigMutation builder.
func (m *AppConfigMutation) Where(ps ...predicate.AppConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppConfig).
func (m *AppConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppConfigMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, appconfig.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appconfig.FieldUpdatedAt)
	}
	if m.auto_sync_workouts != nil {
		fields = append(fields, appconfig.FieldAutoSyncWorkouts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appconfig.FieldCreatedAt:
		return m.CreatedAt()
	case appconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case appconfig.FieldAutoSyncWorkouts:
		return m.AutoSyncWorkouts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appconfig.FieldAutoSyncWorkouts:
		return m.OldAutoSyncWorkouts(ctx)
	}
	return nil, fmt.Errorf("unknown AppConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appconfig.FieldAutoSyncWorkouts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSyncWorkouts(v)
		return nil
	}
	return fmt.Errorf("unknown AppConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppConfigMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppConfigMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppConfigMutation) ResetField(name string) error {
	switch name {
	case appconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appconfig.FieldAutoSyncWorkouts:
		m.ResetAutoSyncWorkouts()
		return nil
	}
	return fmt.Errorf("unknown AppConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, appconfig.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appconfig.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, appconfig.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case appconfig.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppConfigMutation) ClearEdge(name string) error {
	switch name {
	case appconfig.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown AppConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppConfigMutation) ResetEdge(name string) error {
	switch name {
	case appconfig.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown AppConfig edge %s", name)
}

// CompetitionMutation represents an operation that mutates the Competition nodes in the graph.
type CompetitionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	public                  *bool
	title                   *string
	description             *string
	start                   *time.Time
	end                     *time.Time
	scheduled               *bool
	status                  *string
	participant_types       *[]string
	appendparticipant_types []string
	workout_types           *[]string
	appendworkout_types     []string
	_type                   *string
	clearedFields           map[string]struct{}
	owner                   *uuid.UUID
	clearedowner            bool
	participants            map[uuid.UUID]struct{}
	removedparticipants     map[uuid.UUID]struct{}
	clearedparticipants     bool
	workouts                map[uuid.UUID]struct{}
	removedworkouts         map[uuid.UUID]struct{}
	clearedworkouts         bool
	workout_data            map[uuid.UUID]struct{}
	removedworkout_data     map[uuid.UUID]struct{}
	clearedworkout_data     bool
	results                 map[uuid.UUID]struct{}
	removedresults          map[uuid.UUID]struct{}
	clearedresults          bool
	done                    bool
	oldValue                func(context.Context) (*Competition, error)
	predicates              []predicate.Competition
}

var _ ent.Mutation = (*CompetitionMutation)(nil)

// competitionOption allows management of the mutation configuration using functional options.
type competitionOption func(*CompetitionMutation)

// newCompetitionMutation creates new mutation for the Competition entity.
func newCompetitionMutation(c config, op Op, opts ...competitionOption) *CompetitionMutation {
	m := &CompetitionMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionID sets the ID field of the mutation.
func withCompetitionID(id uuid.UUID) competitionOption {
	return func(m *CompetitionMutation) {
		var (
			err   error
			once  sync.Once
			value *Competition
		)
		m.oldValue = func(ctx context.Context) (*Competition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Competition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetition sets the old Competition of the mutation.
func withCompetition(node *Competition) competitionOption {
	return func(m *CompetitionMutation) {
		m.oldValue = func(context.Context) (*Competition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Competition entities.
func (m *CompetitionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Competition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompetitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompetitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompetitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompetitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompetitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompetitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPublic sets the "public" field.
func (m *CompetitionMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *CompetitionMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *CompetitionMutation) ResetPublic() {
	m.public = nil
}

// SetTitle sets the "title" field.
func (m *CompetitionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CompetitionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CompetitionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CompetitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompetitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CompetitionMutation) ResetDescription() {
	m.description = nil
}

// SetStart sets the "start" field.
func (m *CompetitionMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *CompetitionMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *CompetitionMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *CompetitionMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *CompetitionMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *CompetitionMutation) ResetEnd() {
	m.end = nil
}

// SetScheduled sets the "scheduled" field.
func (m *CompetitionMutation) SetScheduled(b bool) {
	m.scheduled = &b
}

// Scheduled returns the value of the "scheduled" field in the mutation.
func (m *CompetitionMutation) Scheduled() (r bool, exists bool) {
	v := m.scheduled
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduled returns the old "scheduled" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldScheduled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduled: %w", err)
	}
	return oldValue.Scheduled, nil
}

// ResetScheduled resets all changes to the "scheduled" field.
func (m *CompetitionMutation) ResetScheduled() {
	m.scheduled = nil
}

// SetStatus sets the "status" field.
func (m *CompetitionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CompetitionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CompetitionMutation) ResetStatus() {
	m.status = nil
}

// SetParticipantTypes sets the "participant_types" field.
func (m *CompetitionMutation) SetParticipantTypes(s []string) {
	m.participant_types = &s
	m.appendparticipant_types = nil
}

// ParticipantTypes returns the value of the "participant_types" field in the mutation.
func (m *CompetitionMutation) ParticipantTypes() (r []string, exists bool) {
	v := m.participant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldParticipantTypes returns the old "participant_types" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldParticipantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParticipantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParticipantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParticipantTypes: %w", err)
	}
	return oldValue.ParticipantTypes, nil
}

// AppendParticipantTypes adds s to the "participant_types" field.
func (m *CompetitionMutation) AppendParticipantTypes(s []string) {
	m.appendparticipant_types = append(m.appendparticipant_types, s...)
}

// AppendedParticipantTypes returns the list of values that were appended to the "participant_types" field in this mutation.
func (m *CompetitionMutation) AppendedParticipantTypes() ([]string, bool) {
	if len(m.appendparticipant_types) == 0 {
		return nil, false
	}
	return m.appendparticipant_types, true
}

// ClearParticipantTypes clears the value of the "participant_types" field.
func (m *CompetitionMutation) ClearParticipantTypes() {
	m.participant_types = nil
	m.appendparticipant_types = nil
	m.clearedFields[competition.FieldParticipantTypes] = struct{}{}
}

// ParticipantTypesCleared returns if the "participant_types" field was cleared in this mutation.
func (m *CompetitionMutation) ParticipantTypesCleared() bool {
	_, ok := m.clearedFields[competition.FieldParticipantTypes]
	return ok
}

// ResetParticipantTypes resets all changes to the "participant_types" field.
func (m *CompetitionMutation) ResetParticipantTypes() {
	m.participant_types = nil
	m.appendparticipant_types = nil
	delete(m.clearedFields, competition.FieldParticipantTypes)
}

// SetWorkoutTypes sets the "workout_types" field.
func (m *CompetitionMutation) SetWorkoutTypes(s []string) {
	m.workout_types = &s
	m.appendworkout_types = nil
}

// WorkoutTypes returns the value of the "workout_types" field in the mutation.
func (m *CompetitionMutation) WorkoutTypes() (r []string, exists bool) {
	v := m.workout_types
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkoutTypes returns the old "workout_types" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldWorkoutTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkoutTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkoutTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkoutTypes: %w", err)
	}
	return oldValue.WorkoutTypes, nil
}

// AppendWorkoutTypes adds s to the "workout_types" field.
func (m *CompetitionMutation) AppendWorkoutTypes(s []string) {
	m.appendworkout_types = append(m.appendworkout_types, s...)
}

// AppendedWorkoutTypes returns the list of values that were appended to the "workout_types" field in this mutation.
func (m *CompetitionMutation) AppendedWorkoutTypes() ([]string, bool) {
	if len(m.appendworkout_types) == 0 {
		return nil, false
	}
	return m.appendworkout_types, true
}

// ClearWorkoutTypes clears the value of the "workout_types" field.
func (m *CompetitionMutation) ClearWorkoutTypes() {
	m.workout_types = nil
	m.appendworkout_types = nil
	m.clearedFields[competition.FieldWorkoutTypes] = struct{}{}
}

// WorkoutTypesCleared returns if the "workout_types" field was cleared in this mutation.
func (m *CompetitionMutation) WorkoutTypesCleared() bool {
	_, ok := m.clearedFields[competition.FieldWorkoutTypes]
	return ok
}

// ResetWorkoutTypes resets all changes to the "workout_types" field.
func (m *CompetitionMutation) ResetWorkoutTypes() {
	m.workout_types = nil
	m.appendworkout_types = nil
	delete(m.clearedFields, competition.FieldWorkoutTypes)
}

// SetType sets the "type" field.
func (m *CompetitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *CompetitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Competition entity.
// If the Competition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CompetitionMutation) ResetType() {
	m._type = nil
}

// SetOwnerID sets the "owner" edge to the Profile entity by id.
func (m *CompetitionMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Profile entity.
func (m *CompetitionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Profile entity was cleared.
func (m *CompetitionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CompetitionMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CompetitionMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CompetitionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddParticipantIDs adds the "participants" edge to the Profile entity by ids.
func (m *CompetitionMutation) AddParticipantIDs(ids ...uuid.UUID) {
	if m.participants == nil {
		m.participants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.participants[ids[i]] = struct{}{}
	}
}

// ClearParticipants clears the "participants" edge to the Profile entity.
func (m *CompetitionMutation) ClearParticipants() {
	m.clearedparticipants = true
}

// ParticipantsCleared reports if the "participants" edge to the Profile entity was cleared.
func (m *CompetitionMutation) ParticipantsCleared() bool {
	return m.clearedparticipants
}

// RemoveParticipantIDs removes the "participants" edge to the Profile entity by IDs.
func (m *CompetitionMutation) RemoveParticipantIDs(ids ...uuid.UUID) {
	if m.removedparticipants == nil {
		m.removedparticipants = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.participants, ids[i])
		m.removedparticipants[ids[i]] = struct{}{}
	}
}

// RemovedParticipants returns the removed IDs of the "participants" edge to the Profile entity.
func (m *CompetitionMutation) RemovedParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.removedparticipants {
		ids = append(ids, id)
	}
	return
}

// ParticipantsIDs returns the "participants" edge IDs in the mutation.
func (m *CompetitionMutation) ParticipantsIDs() (ids []uuid.UUID) {
	for id := range m.participants {
		ids = append(ids, id)
	}
	return
}

// ResetParticipants resets all changes to the "participants" edge.
func (m *CompetitionMutation) ResetParticipants() {
	m.participants = nil
	m.clearedparticipants = false
	m.removedparticipants = nil
}

// AddWorkoutIDs adds the "workouts" edge to the Workout entity by ids.
func (m *CompetitionMutation) AddWorkoutIDs(ids ...uuid.UUID) {
	if m.workouts == nil {
		m.workouts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workouts[ids[i]] = struct{}{}
	}
}

// ClearWorkouts clears the "workouts" edge to the Workout entity.
func (m *CompetitionMutation) ClearWorkouts() {
	m.clearedworkouts = true
}

// WorkoutsCleared reports if the "workouts" edge to the Workout entity was cleared.
func (m *CompetitionMutation) WorkoutsCleared() bool {
	return m.clearedworkouts
}

// RemoveWorkoutIDs removes the "workouts" edge to the Workout entity by IDs.
func (m *CompetitionMutation) RemoveWorkoutIDs(ids ...uuid.UUID) {
	if m.removedworkouts == nil {
		m.removedworkouts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workouts, ids[i])
		m.removedworkouts[ids[i]] = struct{}{}
	}
}

// RemovedWorkouts returns the removed IDs of the "workouts" edge to the Workout entity.
func (m *CompetitionMutation) RemovedWorkoutsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkouts {
		ids = append(ids, id)
	}
	return
}

// WorkoutsIDs returns the "workouts" edge IDs in the mutation.
func (m *CompetitionMutation) WorkoutsIDs() (ids []uuid.UUID) {
	for id := range m.workouts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkouts resets all changes to the "workouts" edge.
func (m *CompetitionMutation) ResetWorkouts() {
	m.workouts = nil
	m.clearedworkouts = false
	m.removedworkouts = nil
}

// AddWorkoutDatumIDs adds the "workout_data" edge to the WorkoutData entity by ids.
func (m *CompetitionMutation) AddWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.workout_data == nil {
		m.workout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workout_data[ids[i]] = struct{}{}
	}
}

// ClearWorkoutData clears the "workout_data" edge to the WorkoutData entity.
func (m *CompetitionMutation) ClearWorkoutData() {
	m.clearedworkout_data = true
}

// WorkoutDataCleared reports if the "workout_data" edge to the WorkoutData entity was cleared.
func (m *CompetitionMutation) WorkoutDataCleared() bool {
	return m.clearedworkout_data
}

// RemoveWorkoutDatumIDs removes the "workout_data" edge to the WorkoutData entity by IDs.
func (m *CompetitionMutation) RemoveWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.removedworkout_data == nil {
		m.removedworkout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workout_data, ids[i])
		m.removedworkout_data[ids[i]] = struct{}{}
	}
}

// RemovedWorkoutData returns the removed IDs of the "workout_data" edge to the WorkoutData entity.
func (m *CompetitionMutation) RemovedWorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.removedworkout_data {
		ids = append(ids, id)
	}
	return
}

// WorkoutDataIDs returns the "workout_data" edge IDs in the mutation.
func (m *CompetitionMutation) WorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.workout_data {
		ids = append(ids, id)
	}
	return
}

// ResetWorkoutData resets all changes to the "workout_data" edge.
func (m *CompetitionMutation) ResetWorkoutData() {
	m.workout_data = nil
	m.clearedworkout_data = false
	m.removedworkout_data = nil
}

// AddResultIDs adds the "results" edge to the CompetitionResult entity by ids.
func (m *CompetitionMutation) AddResultIDs(ids ...uuid.UUID) {
	if m.results == nil {
		m.results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the CompetitionResult entity.
func (m *CompetitionMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the CompetitionResult entity was cleared.
func (m *CompetitionMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the CompetitionResult entity by IDs.
func (m *CompetitionMutation) RemoveResultIDs(ids ...uuid.UUID) {
	if m.removedresults == nil {
		m.removedresults = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the CompetitionResult entity.
func (m *CompetitionMutation) RemovedResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *CompetitionMutation) ResultsIDs() (ids []uuid.UUID) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *CompetitionMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// Where appends a list predicates to the CompetitionMutation builder.
func (m *CompetitionMutation) Where(ps ...predicate.Competition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Competition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Competition).
func (m *CompetitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, competition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, competition.FieldUpdatedAt)
	}
	if m.public != nil {
		fields = append(fields, competition.FieldPublic)
	}
	if m.title != nil {
		fields = append(fields, competition.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, competition.FieldDescription)
	}
	if m.start != nil {
		fields = append(fields, competition.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, competition.FieldEnd)
	}
	if m.scheduled != nil {
		fields = append(fields, competition.FieldScheduled)
	}
	if m.status != nil {
		fields = append(fields, competition.FieldStatus)
	}
	if m.participant_types != nil {
		fields = append(fields, competition.FieldParticipantTypes)
	}
	if m.workout_types != nil {
		fields = append(fields, competition.FieldWorkoutTypes)
	}
	if m._type != nil {
		fields = append(fields, competition.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competition.FieldCreatedAt:
		return m.CreatedAt()
	case competition.FieldUpdatedAt:
		return m.UpdatedAt()
	case competition.FieldPublic:
		return m.Public()
	case competition.FieldTitle:
		return m.Title()
	case competition.FieldDescription:
		return m.Description()
	case competition.FieldStart:
		return m.Start()
	case competition.FieldEnd:
		return m.End()
	case competition.FieldScheduled:
		return m.Scheduled()
	case competition.FieldStatus:
		return m.Status()
	case competition.FieldParticipantTypes:
		return m.ParticipantTypes()
	case competition.FieldWorkoutTypes:
		return m.WorkoutTypes()
	case competition.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case competition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case competition.FieldPublic:
		return m.OldPublic(ctx)
	case competition.FieldTitle:
		return m.OldTitle(ctx)
	case competition.FieldDescription:
		return m.OldDescription(ctx)
	case competition.FieldStart:
		return m.OldStart(ctx)
	case competition.FieldEnd:
		return m.OldEnd(ctx)
	case competition.FieldScheduled:
		return m.OldScheduled(ctx)
	case competition.FieldStatus:
		return m.OldStatus(ctx)
	case competition.FieldParticipantTypes:
		return m.OldParticipantTypes(ctx)
	case competition.FieldWorkoutTypes:
		return m.OldWorkoutTypes(ctx)
	case competition.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Competition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case competition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case competition.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case competition.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case competition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case competition.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case competition.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case competition.FieldScheduled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduled(v)
		return nil
	case competition.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case competition.FieldParticipantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParticipantTypes(v)
		return nil
	case competition.FieldWorkoutTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkoutTypes(v)
		return nil
	case competition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Competition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(competition.FieldParticipantTypes) {
		fields = append(fields, competition.FieldParticipantTypes)
	}
	if m.FieldCleared(competition.FieldWorkoutTypes) {
		fields = append(fields, competition.FieldWorkoutTypes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionMutation) ClearField(name string) error {
	switch name {
	case competition.FieldParticipantTypes:
		m.ClearParticipantTypes()
		return nil
	case competition.FieldWorkoutTypes:
		m.ClearWorkoutTypes()
		return nil
	}
	return fmt.Errorf("unknown Competition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionMutation) ResetField(name string) error {
	switch name {
	case competition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case competition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case competition.FieldPublic:
		m.ResetPublic()
		return nil
	case competition.FieldTitle:
		m.ResetTitle()
		return nil
	case competition.FieldDescription:
		m.ResetDescription()
		return nil
	case competition.FieldStart:
		m.ResetStart()
		return nil
	case competition.FieldEnd:
		m.ResetEnd()
		return nil
	case competition.FieldScheduled:
		m.ResetScheduled()
		return nil
	case competition.FieldStatus:
		m.ResetStatus()
		return nil
	case competition.FieldParticipantTypes:
		m.ResetParticipantTypes()
		return nil
	case competition.FieldWorkoutTypes:
		m.ResetWorkoutTypes()
		return nil
	case competition.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Competition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, competition.EdgeOwner)
	}
	if m.participants != nil {
		edges = append(edges, competition.EdgeParticipants)
	}
	if m.workouts != nil {
		edges = append(edges, competition.EdgeWorkouts)
	}
	if m.workout_data != nil {
		edges = append(edges, competition.EdgeWorkoutData)
	}
	if m.results != nil {
		edges = append(edges, competition.EdgeResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case competition.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.participants))
		for id := range m.participants {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeWorkouts:
		ids := make([]ent.Value, 0, len(m.workouts))
		for id := range m.workouts {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.workout_data))
		for id := range m.workout_data {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedparticipants != nil {
		edges = append(edges, competition.EdgeParticipants)
	}
	if m.removedworkouts != nil {
		edges = append(edges, competition.EdgeWorkouts)
	}
	if m.removedworkout_data != nil {
		edges = append(edges, competition.EdgeWorkoutData)
	}
	if m.removedresults != nil {
		edges = append(edges, competition.EdgeResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case competition.EdgeParticipants:
		ids := make([]ent.Value, 0, len(m.removedparticipants))
		for id := range m.removedparticipants {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeWorkouts:
		ids := make([]ent.Value, 0, len(m.removedworkouts))
		for id := range m.removedworkouts {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.removedworkout_data))
		for id := range m.removedworkout_data {
			ids = append(ids, id)
		}
		return ids
	case competition.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, competition.EdgeOwner)
	}
	if m.clearedparticipants {
		edges = append(edges, competition.EdgeParticipants)
	}
	if m.clearedworkouts {
		edges = append(edges, competition.EdgeWorkouts)
	}
	if m.clearedworkout_data {
		edges = append(edges, competition.EdgeWorkoutData)
	}
	if m.clearedresults {
		edges = append(edges, competition.EdgeResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionMutation) EdgeCleared(name string) bool {
	switch name {
	case competition.EdgeOwner:
		return m.clearedowner
	case competition.EdgeParticipants:
		return m.clearedparticipants
	case competition.EdgeWorkouts:
		return m.clearedworkouts
	case competition.EdgeWorkoutData:
		return m.clearedworkout_data
	case competition.EdgeResults:
		return m.clearedresults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionMutation) ClearEdge(name string) error {
	switch name {
	case competition.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Competition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionMutation) ResetEdge(name string) error {
	switch name {
	case competition.EdgeOwner:
		m.ResetOwner()
		return nil
	case competition.EdgeParticipants:
		m.ResetParticipants()
		return nil
	case competition.EdgeWorkouts:
		m.ResetWorkouts()
		return nil
	case competition.EdgeWorkoutData:
		m.ResetWorkoutData()
		return nil
	case competition.EdgeResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown Competition edge %s", name)
}

// CompetitionResultMutation represents an operation that mutates the CompetitionResult nodes in the graph.
type CompetitionResultMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	place              *string
	clearedFields      map[string]struct{}
	competition        *uuid.UUID
	clearedcompetition bool
	profile            *uuid.UUID
	clearedprofile     bool
	squad              *uuid.UUID
	clearedsquad       bool
	done               bool
	oldValue           func(context.Context) (*CompetitionResult, error)
	predicates         []predicate.CompetitionResult
}

var _ ent.Mutation = (*CompetitionResultMutation)(nil)

// competitionresultOption allows management of the mutation configuration using functional options.
type competitionresultOption func(*CompetitionResultMutation)

// newCompetitionResultMutation creates new mutation for the CompetitionResult entity.
func newCompetitionResultMutation(c config, op Op, opts ...competitionresultOption) *CompetitionResultMutation {
	m := &CompetitionResultMutation{
		config:        c,
		op:            op,
		typ:           TypeCompetitionResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompetitionResultID sets the ID field of the mutation.
func withCompetitionResultID(id uuid.UUID) competitionresultOption {
	return func(m *CompetitionResultMutation) {
		var (
			err   error
			once  sync.Once
			value *CompetitionResult
		)
		m.oldValue = func(ctx context.Context) (*CompetitionResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompetitionResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompetitionResult sets the old CompetitionResult of the mutation.
func withCompetitionResult(node *CompetitionResult) competitionresultOption {
	return func(m *CompetitionResultMutation) {
		m.oldValue = func(context.Context) (*CompetitionResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompetitionResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompetitionResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CompetitionResult entities.
func (m *CompetitionResultMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompetitionResultMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompetitionResultMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompetitionResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CompetitionResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CompetitionResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CompetitionResult entity.
// If the CompetitionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CompetitionResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CompetitionResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CompetitionResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CompetitionResult entity.
// If the CompetitionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CompetitionResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPlace sets the "place" field.
func (m *CompetitionResultMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *CompetitionResultMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the CompetitionResult entity.
// If the CompetitionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompetitionResultMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *CompetitionResultMutation) ResetPlace() {
	m.place = nil
}

// SetCompetitionID sets the "competition" edge to the Competition entity by id.
func (m *CompetitionResultMutation) SetCompetitionID(id uuid.UUID) {
	m.competition = &id
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *CompetitionResultMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *CompetitionResultMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionID returns the "competition" edge ID in the mutation.
func (m *CompetitionResultMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m.competition != nil {
		return *m.competition, true
	}
	return
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *CompetitionResultMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *CompetitionResultMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *CompetitionResultMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *CompetitionResultMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *CompetitionResultMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *CompetitionResultMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *CompetitionResultMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *CompetitionResultMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetSquadID sets the "squad" edge to the Squad entity by id.
func (m *CompetitionResultMutation) SetSquadID(id uuid.UUID) {
	m.squad = &id
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *CompetitionResultMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *CompetitionResultMutation) SquadCleared() bool {
	return m.clearedsquad
}

// SquadID returns the "squad" edge ID in the mutation.
func (m *CompetitionResultMutation) SquadID() (id uuid.UUID, exists bool) {
	if m.squad != nil {
		return *m.squad, true
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SquadID instead. It exists only for internal usage by the builders.
func (m *CompetitionResultMutation) SquadIDs() (ids []uuid.UUID) {
	if id := m.squad; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *CompetitionResultMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
}

// Where appends a list predicates to the CompetitionResultMutation builder.
func (m *CompetitionResultMutation) Where(ps ...predicate.CompetitionResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompetitionResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompetitionResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompetitionResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompetitionResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompetitionResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompetitionResult).
func (m *CompetitionResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompetitionResultMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, competitionresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, competitionresult.FieldUpdatedAt)
	}
	if m.place != nil {
		fields = append(fields, competitionresult.FieldPlace)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompetitionResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case competitionresult.FieldCreatedAt:
		return m.CreatedAt()
	case competitionresult.FieldUpdatedAt:
		return m.UpdatedAt()
	case competitionresult.FieldPlace:
		return m.Place()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompetitionResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case competitionresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case competitionresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case competitionresult.FieldPlace:
		return m.OldPlace(ctx)
	}
	return nil, fmt.Errorf("unknown CompetitionResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case competitionresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case competitionresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case competitionresult.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	}
	return fmt.Errorf("unknown CompetitionResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompetitionResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompetitionResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompetitionResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CompetitionResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompetitionResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompetitionResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompetitionResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompetitionResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompetitionResultMutation) ResetField(name string) error {
	switch name {
	case competitionresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case competitionresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case competitionresult.FieldPlace:
		m.ResetPlace()
		return nil
	}
	return fmt.Errorf("unknown CompetitionResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompetitionResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.competition != nil {
		edges = append(edges, competitionresult.EdgeCompetition)
	}
	if m.profile != nil {
		edges = append(edges, competitionresult.EdgeProfile)
	}
	if m.squad != nil {
		edges = append(edges, competitionresult.EdgeSquad)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompetitionResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case competitionresult.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case competitionresult.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case competitionresult.EdgeSquad:
		if id := m.squad; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompetitionResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompetitionResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompetitionResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompetition {
		edges = append(edges, competitionresult.EdgeCompetition)
	}
	if m.clearedprofile {
		edges = append(edges, competitionresult.EdgeProfile)
	}
	if m.clearedsquad {
		edges = append(edges, competitionresult.EdgeSquad)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompetitionResultMutation) EdgeCleared(name string) bool {
	switch name {
	case competitionresult.EdgeCompetition:
		return m.clearedcompetition
	case competitionresult.EdgeProfile:
		return m.clearedprofile
	case competitionresult.EdgeSquad:
		return m.clearedsquad
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompetitionResultMutation) ClearEdge(name string) error {
	switch name {
	case competitionresult.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case competitionresult.EdgeProfile:
		m.ClearProfile()
		return nil
	case competitionresult.EdgeSquad:
		m.ClearSquad()
		return nil
	}
	return fmt.Errorf("unknown CompetitionResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompetitionResultMutation) ResetEdge(name string) error {
	switch name {
	case competitionresult.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case competitionresult.EdgeProfile:
		m.ResetProfile()
		return nil
	case competitionresult.EdgeSquad:
		m.ResetSquad()
		return nil
	}
	return fmt.Errorf("unknown CompetitionResult edge %s", name)
}

// FcmTokenMutation represents an operation that mutates the FcmToken nodes in the graph.
type FcmTokenMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	token          *string
	clearedFields  map[string]struct{}
	profile        *uuid.UUID
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*FcmToken, error)
	predicates     []predicate.FcmToken
}

var _ ent.Mutation = (*FcmTokenMutation)(nil)

// fcmtokenOption allows management of the mutation configuration using functional options.
type fcmtokenOption func(*FcmTokenMutation)

// newFcmTokenMutation creates new mutation for the FcmToken entity.
func newFcmTokenMutation(c config, op Op, opts ...fcmtokenOption) *FcmTokenMutation {
	m := &FcmTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeFcmToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFcmTokenID sets the ID field of the mutation.
func withFcmTokenID(id uuid.UUID) fcmtokenOption {
	return func(m *FcmTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *FcmToken
		)
		m.oldValue = func(ctx context.Context) (*FcmToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FcmToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFcmToken sets the old FcmToken of the mutation.
func withFcmToken(node *FcmToken) fcmtokenOption {
	return func(m *FcmTokenMutation) {
		m.oldValue = func(context.Context) (*FcmToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FcmTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FcmTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FcmToken entities.
func (m *FcmTokenMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FcmTokenMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FcmTokenMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FcmToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FcmTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FcmTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FcmToken entity.
// If the FcmToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FcmTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FcmTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FcmTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FcmTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FcmToken entity.
// If the FcmToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FcmTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FcmTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetToken sets the "token" field.
func (m *FcmTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *FcmTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the FcmToken entity.
// If the FcmToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FcmTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *FcmTokenMutation) ResetToken() {
	m.token = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *FcmTokenMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *FcmTokenMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *FcmTokenMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *FcmTokenMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *FcmTokenMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *FcmTokenMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the FcmTokenMutation builder.
func (m *FcmTokenMutation) Where(ps ...predicate.FcmToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FcmTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FcmTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FcmToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FcmTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FcmTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FcmToken).
func (m *FcmTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FcmTokenMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, fcmtoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fcmtoken.FieldUpdatedAt)
	}
	if m.token != nil {
		fields = append(fields, fcmtoken.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FcmTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fcmtoken.FieldCreatedAt:
		return m.CreatedAt()
	case fcmtoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case fcmtoken.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FcmTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fcmtoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fcmtoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fcmtoken.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown FcmToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FcmTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fcmtoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fcmtoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fcmtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown FcmToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FcmTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FcmTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FcmTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FcmToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FcmTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FcmTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FcmTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FcmToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FcmTokenMutation) ResetField(name string) error {
	switch name {
	case fcmtoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fcmtoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fcmtoken.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown FcmToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FcmTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, fcmtoken.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FcmTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fcmtoken.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FcmTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FcmTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FcmTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, fcmtoken.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FcmTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case fcmtoken.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FcmTokenMutation) ClearEdge(name string) error {
	switch name {
	case fcmtoken.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown FcmToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FcmTokenMutation) ResetEdge(name string) error {
	switch name {
	case fcmtoken.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown FcmToken edge %s", name)
}

// GoalMutation represents an operation that mutates the Goal nodes in the graph.
type GoalMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	_type                           *string
	start                           *time.Time
	end                             *time.Time
	healthkit_workout_activity_type *string
	action                          *string
	value                           *string
	unit                            *string
	value_aggregation_type          *string
	time_interval                   *string
	status                          *string
	current_total_value             *string
	per_workout_data                *[]shared.PerWorkoutGoalDataEntry
	appendper_workout_data          []shared.PerWorkoutGoalDataEntry
	clearedFields                   map[string]struct{}
	profile                         *uuid.UUID
	clearedprofile                  bool
	competition                     *uuid.UUID
	clearedcompetition              bool
	squad                           *uuid.UUID
	clearedsquad                    bool
	done                            bool
	oldValue                        func(context.Context) (*Goal, error)
	predicates                      []predicate.Goal
}

var _ ent.Mutation = (*GoalMutation)(nil)

// goalOption allows management of the mutation configuration using functional options.
type goalOption func(*GoalMutation)

// newGoalMutation creates new mutation for the Goal entity.
func newGoalMutation(c config, op Op, opts ...goalOption) *GoalMutation {
	m := &GoalMutation{
		config:        c,
		op:            op,
		typ:           TypeGoal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoalID sets the ID field of the mutation.
func withGoalID(id uuid.UUID) goalOption {
	return func(m *GoalMutation) {
		var (
			err   error
			once  sync.Once
			value *Goal
		)
		m.oldValue = func(ctx context.Context) (*Goal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Goal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoal sets the old Goal of the mutation.
func withGoal(node *Goal) goalOption {
	return func(m *GoalMutation) {
		m.oldValue = func(context.Context) (*Goal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Goal entities.
func (m *GoalMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoalMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoalMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Goal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *GoalMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *GoalMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *GoalMutation) ResetType() {
	m._type = nil
}

// SetStart sets the "start" field.
func (m *GoalMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *GoalMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *GoalMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *GoalMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *GoalMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *GoalMutation) ResetEnd() {
	m.end = nil
}

// SetHealthkitWorkoutActivityType sets the "healthkit_workout_activity_type" field.
func (m *GoalMutation) SetHealthkitWorkoutActivityType(s string) {
	m.healthkit_workout_activity_type = &s
}

// HealthkitWorkoutActivityType returns the value of the "healthkit_workout_activity_type" field in the mutation.
func (m *GoalMutation) HealthkitWorkoutActivityType() (r string, exists bool) {
	v := m.healthkit_workout_activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthkitWorkoutActivityType returns the old "healthkit_workout_activity_type" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldHealthkitWorkoutActivityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthkitWorkoutActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthkitWorkoutActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthkitWorkoutActivityType: %w", err)
	}
	return oldValue.HealthkitWorkoutActivityType, nil
}

// ClearHealthkitWorkoutActivityType clears the value of the "healthkit_workout_activity_type" field.
func (m *GoalMutation) ClearHealthkitWorkoutActivityType() {
	m.healthkit_workout_activity_type = nil
	m.clearedFields[goal.FieldHealthkitWorkoutActivityType] = struct{}{}
}

// HealthkitWorkoutActivityTypeCleared returns if the "healthkit_workout_activity_type" field was cleared in this mutation.
func (m *GoalMutation) HealthkitWorkoutActivityTypeCleared() bool {
	_, ok := m.clearedFields[goal.FieldHealthkitWorkoutActivityType]
	return ok
}

// ResetHealthkitWorkoutActivityType resets all changes to the "healthkit_workout_activity_type" field.
func (m *GoalMutation) ResetHealthkitWorkoutActivityType() {
	m.healthkit_workout_activity_type = nil
	delete(m.clearedFields, goal.FieldHealthkitWorkoutActivityType)
}

// SetAction sets the "action" field.
func (m *GoalMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *GoalMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *GoalMutation) ResetAction() {
	m.action = nil
}

// SetValue sets the "value" field.
func (m *GoalMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *GoalMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *GoalMutation) ResetValue() {
	m.value = nil
}

// SetUnit sets the "unit" field.
func (m *GoalMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *GoalMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *GoalMutation) ResetUnit() {
	m.unit = nil
}

// SetValueAggregationType sets the "value_aggregation_type" field.
func (m *GoalMutation) SetValueAggregationType(s string) {
	m.value_aggregation_type = &s
}

// ValueAggregationType returns the value of the "value_aggregation_type" field in the mutation.
func (m *GoalMutation) ValueAggregationType() (r string, exists bool) {
	v := m.value_aggregation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldValueAggregationType returns the old "value_aggregation_type" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldValueAggregationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValueAggregationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValueAggregationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueAggregationType: %w", err)
	}
	return oldValue.ValueAggregationType, nil
}

// ResetValueAggregationType resets all changes to the "value_aggregation_type" field.
func (m *GoalMutation) ResetValueAggregationType() {
	m.value_aggregation_type = nil
}

// SetTimeInterval sets the "time_interval" field.
func (m *GoalMutation) SetTimeInterval(s string) {
	m.time_interval = &s
}

// TimeInterval returns the value of the "time_interval" field in the mutation.
func (m *GoalMutation) TimeInterval() (r string, exists bool) {
	v := m.time_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeInterval returns the old "time_interval" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldTimeInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeInterval: %w", err)
	}
	return oldValue.TimeInterval, nil
}

// ResetTimeInterval resets all changes to the "time_interval" field.
func (m *GoalMutation) ResetTimeInterval() {
	m.time_interval = nil
}

// SetStatus sets the "status" field.
func (m *GoalMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GoalMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GoalMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentTotalValue sets the "current_total_value" field.
func (m *GoalMutation) SetCurrentTotalValue(s string) {
	m.current_total_value = &s
}

// CurrentTotalValue returns the value of the "current_total_value" field in the mutation.
func (m *GoalMutation) CurrentTotalValue() (r string, exists bool) {
	v := m.current_total_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentTotalValue returns the old "current_total_value" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldCurrentTotalValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentTotalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentTotalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentTotalValue: %w", err)
	}
	return oldValue.CurrentTotalValue, nil
}

// ClearCurrentTotalValue clears the value of the "current_total_value" field.
func (m *GoalMutation) ClearCurrentTotalValue() {
	m.current_total_value = nil
	m.clearedFields[goal.FieldCurrentTotalValue] = struct{}{}
}

// CurrentTotalValueCleared returns if the "current_total_value" field was cleared in this mutation.
func (m *GoalMutation) CurrentTotalValueCleared() bool {
	_, ok := m.clearedFields[goal.FieldCurrentTotalValue]
	return ok
}

// ResetCurrentTotalValue resets all changes to the "current_total_value" field.
func (m *GoalMutation) ResetCurrentTotalValue() {
	m.current_total_value = nil
	delete(m.clearedFields, goal.FieldCurrentTotalValue)
}

// SetPerWorkoutData sets the "per_workout_data" field.
func (m *GoalMutation) SetPerWorkoutData(swgde []shared.PerWorkoutGoalDataEntry) {
	m.per_workout_data = &swgde
	m.appendper_workout_data = nil
}

// PerWorkoutData returns the value of the "per_workout_data" field in the mutation.
func (m *GoalMutation) PerWorkoutData() (r []shared.PerWorkoutGoalDataEntry, exists bool) {
	v := m.per_workout_data
	if v == nil {
		return
	}
	return *v, true
}

// OldPerWorkoutData returns the old "per_workout_data" field's value of the Goal entity.
// If the Goal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoalMutation) OldPerWorkoutData(ctx context.Context) (v []shared.PerWorkoutGoalDataEntry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerWorkoutData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerWorkoutData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerWorkoutData: %w", err)
	}
	return oldValue.PerWorkoutData, nil
}

// AppendPerWorkoutData adds swgde to the "per_workout_data" field.
func (m *GoalMutation) AppendPerWorkoutData(swgde []shared.PerWorkoutGoalDataEntry) {
	m.appendper_workout_data = append(m.appendper_workout_data, swgde...)
}

// AppendedPerWorkoutData returns the list of values that were appended to the "per_workout_data" field in this mutation.
func (m *GoalMutation) AppendedPerWorkoutData() ([]shared.PerWorkoutGoalDataEntry, bool) {
	if len(m.appendper_workout_data) == 0 {
		return nil, false
	}
	return m.appendper_workout_data, true
}

// ClearPerWorkoutData clears the value of the "per_workout_data" field.
func (m *GoalMutation) ClearPerWorkoutData() {
	m.per_workout_data = nil
	m.appendper_workout_data = nil
	m.clearedFields[goal.FieldPerWorkoutData] = struct{}{}
}

// PerWorkoutDataCleared returns if the "per_workout_data" field was cleared in this mutation.
func (m *GoalMutation) PerWorkoutDataCleared() bool {
	_, ok := m.clearedFields[goal.FieldPerWorkoutData]
	return ok
}

// ResetPerWorkoutData resets all changes to the "per_workout_data" field.
func (m *GoalMutation) ResetPerWorkoutData() {
	m.per_workout_data = nil
	m.appendper_workout_data = nil
	delete(m.clearedFields, goal.FieldPerWorkoutData)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *GoalMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *GoalMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *GoalMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *GoalMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *GoalMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *GoalMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetCompetitionID sets the "competition" edge to the Competition entity by id.
func (m *GoalMutation) SetCompetitionID(id uuid.UUID) {
	m.competition = &id
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *GoalMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *GoalMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionID returns the "competition" edge ID in the mutation.
func (m *GoalMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m.competition != nil {
		return *m.competition, true
	}
	return
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *GoalMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *GoalMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// SetSquadID sets the "squad" edge to the Squad entity by id.
func (m *GoalMutation) SetSquadID(id uuid.UUID) {
	m.squad = &id
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *GoalMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *GoalMutation) SquadCleared() bool {
	return m.clearedsquad
}

// SquadID returns the "squad" edge ID in the mutation.
func (m *GoalMutation) SquadID() (id uuid.UUID, exists bool) {
	if m.squad != nil {
		return *m.squad, true
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SquadID instead. It exists only for internal usage by the builders.
func (m *GoalMutation) SquadIDs() (ids []uuid.UUID) {
	if id := m.squad; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *GoalMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
}

// Where appends a list predicates to the GoalMutation builder.
func (m *GoalMutation) Where(ps ...predicate.Goal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Goal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Goal).
func (m *GoalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoalMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, goal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, goal.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, goal.FieldType)
	}
	if m.start != nil {
		fields = append(fields, goal.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, goal.FieldEnd)
	}
	if m.healthkit_workout_activity_type != nil {
		fields = append(fields, goal.FieldHealthkitWorkoutActivityType)
	}
	if m.action != nil {
		fields = append(fields, goal.FieldAction)
	}
	if m.value != nil {
		fields = append(fields, goal.FieldValue)
	}
	if m.unit != nil {
		fields = append(fields, goal.FieldUnit)
	}
	if m.value_aggregation_type != nil {
		fields = append(fields, goal.FieldValueAggregationType)
	}
	if m.time_interval != nil {
		fields = append(fields, goal.FieldTimeInterval)
	}
	if m.status != nil {
		fields = append(fields, goal.FieldStatus)
	}
	if m.current_total_value != nil {
		fields = append(fields, goal.FieldCurrentTotalValue)
	}
	if m.per_workout_data != nil {
		fields = append(fields, goal.FieldPerWorkoutData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goal.FieldCreatedAt:
		return m.CreatedAt()
	case goal.FieldUpdatedAt:
		return m.UpdatedAt()
	case goal.FieldType:
		return m.GetType()
	case goal.FieldStart:
		return m.Start()
	case goal.FieldEnd:
		return m.End()
	case goal.FieldHealthkitWorkoutActivityType:
		return m.HealthkitWorkoutActivityType()
	case goal.FieldAction:
		return m.Action()
	case goal.FieldValue:
		return m.Value()
	case goal.FieldUnit:
		return m.Unit()
	case goal.FieldValueAggregationType:
		return m.ValueAggregationType()
	case goal.FieldTimeInterval:
		return m.TimeInterval()
	case goal.FieldStatus:
		return m.Status()
	case goal.FieldCurrentTotalValue:
		return m.CurrentTotalValue()
	case goal.FieldPerWorkoutData:
		return m.PerWorkoutData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case goal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case goal.FieldType:
		return m.OldType(ctx)
	case goal.FieldStart:
		return m.OldStart(ctx)
	case goal.FieldEnd:
		return m.OldEnd(ctx)
	case goal.FieldHealthkitWorkoutActivityType:
		return m.OldHealthkitWorkoutActivityType(ctx)
	case goal.FieldAction:
		return m.OldAction(ctx)
	case goal.FieldValue:
		return m.OldValue(ctx)
	case goal.FieldUnit:
		return m.OldUnit(ctx)
	case goal.FieldValueAggregationType:
		return m.OldValueAggregationType(ctx)
	case goal.FieldTimeInterval:
		return m.OldTimeInterval(ctx)
	case goal.FieldStatus:
		return m.OldStatus(ctx)
	case goal.FieldCurrentTotalValue:
		return m.OldCurrentTotalValue(ctx)
	case goal.FieldPerWorkoutData:
		return m.OldPerWorkoutData(ctx)
	}
	return nil, fmt.Errorf("unknown Goal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case goal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case goal.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case goal.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case goal.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case goal.FieldHealthkitWorkoutActivityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthkitWorkoutActivityType(v)
		return nil
	case goal.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case goal.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case goal.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case goal.FieldValueAggregationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueAggregationType(v)
		return nil
	case goal.FieldTimeInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeInterval(v)
		return nil
	case goal.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case goal.FieldCurrentTotalValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentTotalValue(v)
		return nil
	case goal.FieldPerWorkoutData:
		v, ok := value.([]shared.PerWorkoutGoalDataEntry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerWorkoutData(v)
		return nil
	}
	return fmt.Errorf("unknown Goal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Goal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(goal.FieldHealthkitWorkoutActivityType) {
		fields = append(fields, goal.FieldHealthkitWorkoutActivityType)
	}
	if m.FieldCleared(goal.FieldCurrentTotalValue) {
		fields = append(fields, goal.FieldCurrentTotalValue)
	}
	if m.FieldCleared(goal.FieldPerWorkoutData) {
		fields = append(fields, goal.FieldPerWorkoutData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoalMutation) ClearField(name string) error {
	switch name {
	case goal.FieldHealthkitWorkoutActivityType:
		m.ClearHealthkitWorkoutActivityType()
		return nil
	case goal.FieldCurrentTotalValue:
		m.ClearCurrentTotalValue()
		return nil
	case goal.FieldPerWorkoutData:
		m.ClearPerWorkoutData()
		return nil
	}
	return fmt.Errorf("unknown Goal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoalMutation) ResetField(name string) error {
	switch name {
	case goal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case goal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case goal.FieldType:
		m.ResetType()
		return nil
	case goal.FieldStart:
		m.ResetStart()
		return nil
	case goal.FieldEnd:
		m.ResetEnd()
		return nil
	case goal.FieldHealthkitWorkoutActivityType:
		m.ResetHealthkitWorkoutActivityType()
		return nil
	case goal.FieldAction:
		m.ResetAction()
		return nil
	case goal.FieldValue:
		m.ResetValue()
		return nil
	case goal.FieldUnit:
		m.ResetUnit()
		return nil
	case goal.FieldValueAggregationType:
		m.ResetValueAggregationType()
		return nil
	case goal.FieldTimeInterval:
		m.ResetTimeInterval()
		return nil
	case goal.FieldStatus:
		m.ResetStatus()
		return nil
	case goal.FieldCurrentTotalValue:
		m.ResetCurrentTotalValue()
		return nil
	case goal.FieldPerWorkoutData:
		m.ResetPerWorkoutData()
		return nil
	}
	return fmt.Errorf("unknown Goal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoalMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.profile != nil {
		edges = append(edges, goal.EdgeProfile)
	}
	if m.competition != nil {
		edges = append(edges, goal.EdgeCompetition)
	}
	if m.squad != nil {
		edges = append(edges, goal.EdgeSquad)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case goal.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case goal.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case goal.EdgeSquad:
		if id := m.squad; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprofile {
		edges = append(edges, goal.EdgeProfile)
	}
	if m.clearedcompetition {
		edges = append(edges, goal.EdgeCompetition)
	}
	if m.clearedsquad {
		edges = append(edges, goal.EdgeSquad)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoalMutation) EdgeCleared(name string) bool {
	switch name {
	case goal.EdgeProfile:
		return m.clearedprofile
	case goal.EdgeCompetition:
		return m.clearedcompetition
	case goal.EdgeSquad:
		return m.clearedsquad
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoalMutation) ClearEdge(name string) error {
	switch name {
	case goal.EdgeProfile:
		m.ClearProfile()
		return nil
	case goal.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case goal.EdgeSquad:
		m.ClearSquad()
		return nil
	}
	return fmt.Errorf("unknown Goal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoalMutation) ResetEdge(name string) error {
	switch name {
	case goal.EdgeProfile:
		m.ResetProfile()
		return nil
	case goal.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case goal.EdgeSquad:
		m.ResetSquad()
		return nil
	}
	return fmt.Errorf("unknown Goal edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	status             *string
	clearedFields      map[string]struct{}
	sender             *uuid.UUID
	clearedsender      bool
	receiver           *uuid.UUID
	clearedreceiver    bool
	squad              *uuid.UUID
	clearedsquad       bool
	competition        *uuid.UUID
	clearedcompetition bool
	workout            *uuid.UUID
	clearedworkout     bool
	done               bool
	oldValue           func(context.Context) (*Invite, error)
	predicates         []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id uuid.UUID) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *InviteMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InviteMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InviteMutation) ResetStatus() {
	m.status = nil
}

// SetSenderID sets the "sender" edge to the Profile entity by id.
func (m *InviteMutation) SetSenderID(id uuid.UUID) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the Profile entity.
func (m *InviteMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the Profile entity was cleared.
func (m *InviteMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *InviteMutation) SenderID() (id uuid.UUID, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *InviteMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetReceiverID sets the "receiver" edge to the Profile entity by id.
func (m *InviteMutation) SetReceiverID(id uuid.UUID) {
	m.receiver = &id
}

// ClearReceiver clears the "receiver" edge to the Profile entity.
func (m *InviteMutation) ClearReceiver() {
	m.clearedreceiver = true
}

// ReceiverCleared reports if the "receiver" edge to the Profile entity was cleared.
func (m *InviteMutation) ReceiverCleared() bool {
	return m.clearedreceiver
}

// ReceiverID returns the "receiver" edge ID in the mutation.
func (m *InviteMutation) ReceiverID() (id uuid.UUID, exists bool) {
	if m.receiver != nil {
		return *m.receiver, true
	}
	return
}

// ReceiverIDs returns the "receiver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiverID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) ReceiverIDs() (ids []uuid.UUID) {
	if id := m.receiver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiver resets all changes to the "receiver" edge.
func (m *InviteMutation) ResetReceiver() {
	m.receiver = nil
	m.clearedreceiver = false
}

// SetSquadID sets the "squad" edge to the Squad entity by id.
func (m *InviteMutation) SetSquadID(id uuid.UUID) {
	m.squad = &id
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *InviteMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *InviteMutation) SquadCleared() bool {
	return m.clearedsquad
}

// SquadID returns the "squad" edge ID in the mutation.
func (m *InviteMutation) SquadID() (id uuid.UUID, exists bool) {
	if m.squad != nil {
		return *m.squad, true
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SquadID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) SquadIDs() (ids []uuid.UUID) {
	if id := m.squad; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *InviteMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
}

// SetCompetitionID sets the "competition" edge to the Competition entity by id.
func (m *InviteMutation) SetCompetitionID(id uuid.UUID) {
	m.competition = &id
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *InviteMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *InviteMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionID returns the "competition" edge ID in the mutation.
func (m *InviteMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m.competition != nil {
		return *m.competition, true
	}
	return
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *InviteMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// SetWorkoutID sets the "workout" edge to the Workout entity by id.
func (m *InviteMutation) SetWorkoutID(id uuid.UUID) {
	m.workout = &id
}

// ClearWorkout clears the "workout" edge to the Workout entity.
func (m *InviteMutation) ClearWorkout() {
	m.clearedworkout = true
}

// WorkoutCleared reports if the "workout" edge to the Workout entity was cleared.
func (m *InviteMutation) WorkoutCleared() bool {
	return m.clearedworkout
}

// WorkoutID returns the "workout" edge ID in the mutation.
func (m *InviteMutation) WorkoutID() (id uuid.UUID, exists bool) {
	if m.workout != nil {
		return *m.workout, true
	}
	return
}

// WorkoutIDs returns the "workout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkoutID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) WorkoutIDs() (ids []uuid.UUID) {
	if id := m.workout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkout resets all changes to the "workout" edge.
func (m *InviteMutation) ResetWorkout() {
	m.workout = nil
	m.clearedworkout = false
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invite.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, invite.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	case invite.FieldUpdatedAt:
		return m.UpdatedAt()
	case invite.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invite.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invite.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invite.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.sender != nil {
		edges = append(edges, invite.EdgeSender)
	}
	if m.receiver != nil {
		edges = append(edges, invite.EdgeReceiver)
	}
	if m.squad != nil {
		edges = append(edges, invite.EdgeSquad)
	}
	if m.competition != nil {
		edges = append(edges, invite.EdgeCompetition)
	}
	if m.workout != nil {
		edges = append(edges, invite.EdgeWorkout)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeReceiver:
		if id := m.receiver; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeSquad:
		if id := m.squad; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeWorkout:
		if id := m.workout; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsender {
		edges = append(edges, invite.EdgeSender)
	}
	if m.clearedreceiver {
		edges = append(edges, invite.EdgeReceiver)
	}
	if m.clearedsquad {
		edges = append(edges, invite.EdgeSquad)
	}
	if m.clearedcompetition {
		edges = append(edges, invite.EdgeCompetition)
	}
	if m.clearedworkout {
		edges = append(edges, invite.EdgeWorkout)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeSender:
		return m.clearedsender
	case invite.EdgeReceiver:
		return m.clearedreceiver
	case invite.EdgeSquad:
		return m.clearedsquad
	case invite.EdgeCompetition:
		return m.clearedcompetition
	case invite.EdgeWorkout:
		return m.clearedworkout
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeSender:
		m.ClearSender()
		return nil
	case invite.EdgeReceiver:
		m.ClearReceiver()
		return nil
	case invite.EdgeSquad:
		m.ClearSquad()
		return nil
	case invite.EdgeCompetition:
		m.ClearCompetition()
		return nil
	case invite.EdgeWorkout:
		m.ClearWorkout()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeSender:
		m.ResetSender()
		return nil
	case invite.EdgeReceiver:
		m.ResetReceiver()
		return nil
	case invite.EdgeSquad:
		m.ResetSquad()
		return nil
	case invite.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case invite.EdgeWorkout:
		m.ResetWorkout()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	title          *string
	body           *string
	sent           *time.Time
	opened         *time.Time
	data           **shared.NotificationData
	clearedFields  map[string]struct{}
	profile        *uuid.UUID
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*Notification, error)
	predicates     []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id uuid.UUID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *NotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *NotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *NotificationMutation) ResetTitle() {
	m.title = nil
}

// SetBody sets the "body" field.
func (m *NotificationMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *NotificationMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *NotificationMutation) ResetBody() {
	m.body = nil
}

// SetSent sets the "sent" field.
func (m *NotificationMutation) SetSent(t time.Time) {
	m.sent = &t
}

// Sent returns the value of the "sent" field in the mutation.
func (m *NotificationMutation) Sent() (r time.Time, exists bool) {
	v := m.sent
	if v == nil {
		return
	}
	return *v, true
}

// OldSent returns the old "sent" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldSent(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSent: %w", err)
	}
	return oldValue.Sent, nil
}

// ResetSent resets all changes to the "sent" field.
func (m *NotificationMutation) ResetSent() {
	m.sent = nil
}

// SetOpened sets the "opened" field.
func (m *NotificationMutation) SetOpened(t time.Time) {
	m.opened = &t
}

// Opened returns the value of the "opened" field in the mutation.
func (m *NotificationMutation) Opened() (r time.Time, exists bool) {
	v := m.opened
	if v == nil {
		return
	}
	return *v, true
}

// OldOpened returns the old "opened" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldOpened(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpened: %w", err)
	}
	return oldValue.Opened, nil
}

// ClearOpened clears the value of the "opened" field.
func (m *NotificationMutation) ClearOpened() {
	m.opened = nil
	m.clearedFields[notification.FieldOpened] = struct{}{}
}

// OpenedCleared returns if the "opened" field was cleared in this mutation.
func (m *NotificationMutation) OpenedCleared() bool {
	_, ok := m.clearedFields[notification.FieldOpened]
	return ok
}

// ResetOpened resets all changes to the "opened" field.
func (m *NotificationMutation) ResetOpened() {
	m.opened = nil
	delete(m.clearedFields, notification.FieldOpened)
}

// SetData sets the "data" field.
func (m *NotificationMutation) SetData(sd *shared.NotificationData) {
	m.data = &sd
}

// Data returns the value of the "data" field in the mutation.
func (m *NotificationMutation) Data() (r *shared.NotificationData, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldData(ctx context.Context) (v *shared.NotificationData, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *NotificationMutation) ClearData() {
	m.data = nil
	m.clearedFields[notification.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *NotificationMutation) DataCleared() bool {
	_, ok := m.clearedFields[notification.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *NotificationMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, notification.FieldData)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *NotificationMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *NotificationMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *NotificationMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *NotificationMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *NotificationMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, notification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notification.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, notification.FieldTitle)
	}
	if m.body != nil {
		fields = append(fields, notification.FieldBody)
	}
	if m.sent != nil {
		fields = append(fields, notification.FieldSent)
	}
	if m.opened != nil {
		fields = append(fields, notification.FieldOpened)
	}
	if m.data != nil {
		fields = append(fields, notification.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldCreatedAt:
		return m.CreatedAt()
	case notification.FieldUpdatedAt:
		return m.UpdatedAt()
	case notification.FieldTitle:
		return m.Title()
	case notification.FieldBody:
		return m.Body()
	case notification.FieldSent:
		return m.Sent()
	case notification.FieldOpened:
		return m.Opened()
	case notification.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notification.FieldTitle:
		return m.OldTitle(ctx)
	case notification.FieldBody:
		return m.OldBody(ctx)
	case notification.FieldSent:
		return m.OldSent(ctx)
	case notification.FieldOpened:
		return m.OldOpened(ctx)
	case notification.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case notification.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case notification.FieldSent:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSent(v)
		return nil
	case notification.FieldOpened:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpened(v)
		return nil
	case notification.FieldData:
		v, ok := value.(*shared.NotificationData)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notification.FieldOpened) {
		fields = append(fields, notification.FieldOpened)
	}
	if m.FieldCleared(notification.FieldData) {
		fields = append(fields, notification.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	switch name {
	case notification.FieldOpened:
		m.ClearOpened()
		return nil
	case notification.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notification.FieldTitle:
		m.ResetTitle()
		return nil
	case notification.FieldBody:
		m.ResetBody()
		return nil
	case notification.FieldSent:
		m.ResetSent()
		return nil
	case notification.FieldOpened:
		m.ResetOpened()
		return nil
	case notification.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, notification.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, notification.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// NotificationPreferencesMutation represents an operation that mutates the NotificationPreferences nodes in the graph.
type NotificationPreferencesMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	settings       **shared.NotificationPreferenceSettings
	clearedFields  map[string]struct{}
	profile        *uuid.UUID
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*NotificationPreferences, error)
	predicates     []predicate.NotificationPreferences
}

var _ ent.Mutation = (*NotificationPreferencesMutation)(nil)

// notificationpreferencesOption allows management of the mutation configuration using functional options.
type notificationpreferencesOption func(*NotificationPreferencesMutation)

// newNotificationPreferencesMutation creates new mutation for the NotificationPreferences entity.
func newNotificationPreferencesMutation(c config, op Op, opts ...notificationpreferencesOption) *NotificationPreferencesMutation {
	m := &NotificationPreferencesMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationPreferences,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationPreferencesID sets the ID field of the mutation.
func withNotificationPreferencesID(id uuid.UUID) notificationpreferencesOption {
	return func(m *NotificationPreferencesMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationPreferences
		)
		m.oldValue = func(ctx context.Context) (*NotificationPreferences, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationPreferences.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationPreferences sets the old NotificationPreferences of the mutation.
func withNotificationPreferences(node *NotificationPreferences) notificationpreferencesOption {
	return func(m *NotificationPreferencesMutation) {
		m.oldValue = func(context.Context) (*NotificationPreferences, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationPreferencesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationPreferencesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotificationPreferences entities.
func (m *NotificationPreferencesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationPreferencesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationPreferencesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationPreferences.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotificationPreferencesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotificationPreferencesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotificationPreferences entity.
// If the NotificationPreferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPreferencesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotificationPreferencesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotificationPreferencesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotificationPreferencesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotificationPreferences entity.
// If the NotificationPreferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPreferencesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotificationPreferencesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSettings sets the "settings" field.
func (m *NotificationPreferencesMutation) SetSettings(sps *shared.NotificationPreferenceSettings) {
	m.settings = &sps
}

// Settings returns the value of the "settings" field in the mutation.
func (m *NotificationPreferencesMutation) Settings() (r *shared.NotificationPreferenceSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the NotificationPreferences entity.
// If the NotificationPreferences object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationPreferencesMutation) OldSettings(ctx context.Context) (v *shared.NotificationPreferenceSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *NotificationPreferencesMutation) ResetSettings() {
	m.settings = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *NotificationPreferencesMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *NotificationPreferencesMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *NotificationPreferencesMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *NotificationPreferencesMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *NotificationPreferencesMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *NotificationPreferencesMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the NotificationPreferencesMutation builder.
func (m *NotificationPreferencesMutation) Where(ps ...predicate.NotificationPreferences) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationPreferencesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationPreferencesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationPreferences, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationPreferencesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationPreferencesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationPreferences).
func (m *NotificationPreferencesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationPreferencesMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, notificationpreferences.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, notificationpreferences.FieldUpdatedAt)
	}
	if m.settings != nil {
		fields = append(fields, notificationpreferences.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationPreferencesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationpreferences.FieldCreatedAt:
		return m.CreatedAt()
	case notificationpreferences.FieldUpdatedAt:
		return m.UpdatedAt()
	case notificationpreferences.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationPreferencesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationpreferences.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notificationpreferences.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notificationpreferences.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationPreferences field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPreferencesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationpreferences.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notificationpreferences.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notificationpreferences.FieldSettings:
		v, ok := value.(*shared.NotificationPreferenceSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationPreferences field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationPreferencesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationPreferencesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationPreferencesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationPreferences numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationPreferencesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationPreferencesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationPreferencesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationPreferences nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationPreferencesMutation) ResetField(name string) error {
	switch name {
	case notificationpreferences.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notificationpreferences.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notificationpreferences.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown NotificationPreferences field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationPreferencesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, notificationpreferences.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationPreferencesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notificationpreferences.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationPreferencesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationPreferencesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationPreferencesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, notificationpreferences.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationPreferencesMutation) EdgeCleared(name string) bool {
	switch name {
	case notificationpreferences.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationPreferencesMutation) ClearEdge(name string) error {
	switch name {
	case notificationpreferences.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationPreferences unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationPreferencesMutation) ResetEdge(name string) error {
	switch name {
	case notificationpreferences.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown NotificationPreferences edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	public        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Post, error)
	predicates    []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id uuid.UUID) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPublic sets the "public" field.
func (m *PostMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *PostMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *PostMutation) ResetPublic() {
	m.public = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.public != nil {
		fields = append(fields, post.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Post edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	public                          *bool
	first_name                      *string
	last_name                       *string
	picture                         *string
	birthday                        *time.Time
	onboarding_completed            *bool
	clearedFields                   map[string]struct{}
	user                            *uuid.UUID
	cleareduser                     bool
	fcm_tokens                      map[uuid.UUID]struct{}
	removedfcm_tokens               map[uuid.UUID]struct{}
	clearedfcm_tokens               bool
	notification_preferences        *uuid.UUID
	clearednotification_preferences bool
	app_config                      *uuid.UUID
	clearedapp_config               bool
	notifications                   map[uuid.UUID]struct{}
	removednotifications            map[uuid.UUID]struct{}
	clearednotifications            bool
	competitions                    map[uuid.UUID]struct{}
	removedcompetitions             map[uuid.UUID]struct{}
	clearedcompetitions             bool
	actions                         map[uuid.UUID]struct{}
	removedactions                  map[uuid.UUID]struct{}
	clearedactions                  bool
	squad                           map[uuid.UUID]struct{}
	removedsquad                    map[uuid.UUID]struct{}
	clearedsquad                    bool
	squads_owned                    map[uuid.UUID]struct{}
	removedsquads_owned             map[uuid.UUID]struct{}
	clearedsquads_owned             bool
	invites                         map[uuid.UUID]struct{}
	removedinvites                  map[uuid.UUID]struct{}
	clearedinvites                  bool
	invites_sent                    map[uuid.UUID]struct{}
	removedinvites_sent             map[uuid.UUID]struct{}
	clearedinvites_sent             bool
	workouts                        map[uuid.UUID]struct{}
	removedworkouts                 map[uuid.UUID]struct{}
	clearedworkouts                 bool
	goals                           map[uuid.UUID]struct{}
	removedgoals                    map[uuid.UUID]struct{}
	clearedgoals                    bool
	workout_data                    map[uuid.UUID]struct{}
	removedworkout_data             map[uuid.UUID]struct{}
	clearedworkout_data             bool
	competition_results             map[uuid.UUID]struct{}
	removedcompetition_results      map[uuid.UUID]struct{}
	clearedcompetition_results      bool
	done                            bool
	oldValue                        func(context.Context) (*Profile, error)
	predicates                      []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPublic sets the "public" field.
func (m *ProfileMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *ProfileMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *ProfileMutation) ResetPublic() {
	m.public = nil
}

// SetFirstName sets the "first_name" field.
func (m *ProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *ProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *ProfileMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *ProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *ProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *ProfileMutation) ResetLastName() {
	m.last_name = nil
}

// SetPicture sets the "picture" field.
func (m *ProfileMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *ProfileMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *ProfileMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[profile.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *ProfileMutation) PictureCleared() bool {
	_, ok := m.clearedFields[profile.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *ProfileMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, profile.FieldPicture)
}

// SetBirthday sets the "birthday" field.
func (m *ProfileMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *ProfileMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBirthday(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *ProfileMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[profile.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *ProfileMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[profile.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *ProfileMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, profile.FieldBirthday)
}

// SetOnboardingCompleted sets the "onboarding_completed" field.
func (m *ProfileMutation) SetOnboardingCompleted(b bool) {
	m.onboarding_completed = &b
}

// OnboardingCompleted returns the value of the "onboarding_completed" field in the mutation.
func (m *ProfileMutation) OnboardingCompleted() (r bool, exists bool) {
	v := m.onboarding_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingCompleted returns the old "onboarding_completed" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldOnboardingCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingCompleted: %w", err)
	}
	return oldValue.OnboardingCompleted, nil
}

// ResetOnboardingCompleted resets all changes to the "onboarding_completed" field.
func (m *ProfileMutation) ResetOnboardingCompleted() {
	m.onboarding_completed = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddFcmTokenIDs adds the "fcm_tokens" edge to the FcmToken entity by ids.
func (m *ProfileMutation) AddFcmTokenIDs(ids ...uuid.UUID) {
	if m.fcm_tokens == nil {
		m.fcm_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.fcm_tokens[ids[i]] = struct{}{}
	}
}

// ClearFcmTokens clears the "fcm_tokens" edge to the FcmToken entity.
func (m *ProfileMutation) ClearFcmTokens() {
	m.clearedfcm_tokens = true
}

// FcmTokensCleared reports if the "fcm_tokens" edge to the FcmToken entity was cleared.
func (m *ProfileMutation) FcmTokensCleared() bool {
	return m.clearedfcm_tokens
}

// RemoveFcmTokenIDs removes the "fcm_tokens" edge to the FcmToken entity by IDs.
func (m *ProfileMutation) RemoveFcmTokenIDs(ids ...uuid.UUID) {
	if m.removedfcm_tokens == nil {
		m.removedfcm_tokens = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.fcm_tokens, ids[i])
		m.removedfcm_tokens[ids[i]] = struct{}{}
	}
}

// RemovedFcmTokens returns the removed IDs of the "fcm_tokens" edge to the FcmToken entity.
func (m *ProfileMutation) RemovedFcmTokensIDs() (ids []uuid.UUID) {
	for id := range m.removedfcm_tokens {
		ids = append(ids, id)
	}
	return
}

// FcmTokensIDs returns the "fcm_tokens" edge IDs in the mutation.
func (m *ProfileMutation) FcmTokensIDs() (ids []uuid.UUID) {
	for id := range m.fcm_tokens {
		ids = append(ids, id)
	}
	return
}

// ResetFcmTokens resets all changes to the "fcm_tokens" edge.
func (m *ProfileMutation) ResetFcmTokens() {
	m.fcm_tokens = nil
	m.clearedfcm_tokens = false
	m.removedfcm_tokens = nil
}

// SetNotificationPreferencesID sets the "notification_preferences" edge to the NotificationPreferences entity by id.
func (m *ProfileMutation) SetNotificationPreferencesID(id uuid.UUID) {
	m.notification_preferences = &id
}

// ClearNotificationPreferences clears the "notification_preferences" edge to the NotificationPreferences entity.
func (m *ProfileMutation) ClearNotificationPreferences() {
	m.clearednotification_preferences = true
}

// NotificationPreferencesCleared reports if the "notification_preferences" edge to the NotificationPreferences entity was cleared.
func (m *ProfileMutation) NotificationPreferencesCleared() bool {
	return m.clearednotification_preferences
}

// NotificationPreferencesID returns the "notification_preferences" edge ID in the mutation.
func (m *ProfileMutation) NotificationPreferencesID() (id uuid.UUID, exists bool) {
	if m.notification_preferences != nil {
		return *m.notification_preferences, true
	}
	return
}

// NotificationPreferencesIDs returns the "notification_preferences" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotificationPreferencesID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) NotificationPreferencesIDs() (ids []uuid.UUID) {
	if id := m.notification_preferences; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotificationPreferences resets all changes to the "notification_preferences" edge.
func (m *ProfileMutation) ResetNotificationPreferences() {
	m.notification_preferences = nil
	m.clearednotification_preferences = false
}

// SetAppConfigID sets the "app_config" edge to the AppConfig entity by id.
func (m *ProfileMutation) SetAppConfigID(id uuid.UUID) {
	m.app_config = &id
}

// ClearAppConfig clears the "app_config" edge to the AppConfig entity.
func (m *ProfileMutation) ClearAppConfig() {
	m.clearedapp_config = true
}

// AppConfigCleared reports if the "app_config" edge to the AppConfig entity was cleared.
func (m *ProfileMutation) AppConfigCleared() bool {
	return m.clearedapp_config
}

// AppConfigID returns the "app_config" edge ID in the mutation.
func (m *ProfileMutation) AppConfigID() (id uuid.UUID, exists bool) {
	if m.app_config != nil {
		return *m.app_config, true
	}
	return
}

// AppConfigIDs returns the "app_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppConfigID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) AppConfigIDs() (ids []uuid.UUID) {
	if id := m.app_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppConfig resets all changes to the "app_config" edge.
func (m *ProfileMutation) ResetAppConfig() {
	m.app_config = nil
	m.clearedapp_config = false
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *ProfileMutation) AddNotificationIDs(ids ...uuid.UUID) {
	if m.notifications == nil {
		m.notifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *ProfileMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *ProfileMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *ProfileMutation) RemoveNotificationIDs(ids ...uuid.UUID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *ProfileMutation) RemovedNotificationsIDs() (ids []uuid.UUID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ProfileMutation) NotificationsIDs() (ids []uuid.UUID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ProfileMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddCompetitionIDs adds the "competitions" edge to the Competition entity by ids.
func (m *ProfileMutation) AddCompetitionIDs(ids ...uuid.UUID) {
	if m.competitions == nil {
		m.competitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.competitions[ids[i]] = struct{}{}
	}
}

// ClearCompetitions clears the "competitions" edge to the Competition entity.
func (m *ProfileMutation) ClearCompetitions() {
	m.clearedcompetitions = true
}

// CompetitionsCleared reports if the "competitions" edge to the Competition entity was cleared.
func (m *ProfileMutation) CompetitionsCleared() bool {
	return m.clearedcompetitions
}

// RemoveCompetitionIDs removes the "competitions" edge to the Competition entity by IDs.
func (m *ProfileMutation) RemoveCompetitionIDs(ids ...uuid.UUID) {
	if m.removedcompetitions == nil {
		m.removedcompetitions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.competitions, ids[i])
		m.removedcompetitions[ids[i]] = struct{}{}
	}
}

// RemovedCompetitions returns the removed IDs of the "competitions" edge to the Competition entity.
func (m *ProfileMutation) RemovedCompetitionsIDs() (ids []uuid.UUID) {
	for id := range m.removedcompetitions {
		ids = append(ids, id)
	}
	return
}

// CompetitionsIDs returns the "competitions" edge IDs in the mutation.
func (m *ProfileMutation) CompetitionsIDs() (ids []uuid.UUID) {
	for id := range m.competitions {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitions resets all changes to the "competitions" edge.
func (m *ProfileMutation) ResetCompetitions() {
	m.competitions = nil
	m.clearedcompetitions = false
	m.removedcompetitions = nil
}

// AddActionIDs adds the "actions" edge to the Action entity by ids.
func (m *ProfileMutation) AddActionIDs(ids ...uuid.UUID) {
	if m.actions == nil {
		m.actions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.actions[ids[i]] = struct{}{}
	}
}

// ClearActions clears the "actions" edge to the Action entity.
func (m *ProfileMutation) ClearActions() {
	m.clearedactions = true
}

// ActionsCleared reports if the "actions" edge to the Action entity was cleared.
func (m *ProfileMutation) ActionsCleared() bool {
	return m.clearedactions
}

// RemoveActionIDs removes the "actions" edge to the Action entity by IDs.
func (m *ProfileMutation) RemoveActionIDs(ids ...uuid.UUID) {
	if m.removedactions == nil {
		m.removedactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.actions, ids[i])
		m.removedactions[ids[i]] = struct{}{}
	}
}

// RemovedActions returns the removed IDs of the "actions" edge to the Action entity.
func (m *ProfileMutation) RemovedActionsIDs() (ids []uuid.UUID) {
	for id := range m.removedactions {
		ids = append(ids, id)
	}
	return
}

// ActionsIDs returns the "actions" edge IDs in the mutation.
func (m *ProfileMutation) ActionsIDs() (ids []uuid.UUID) {
	for id := range m.actions {
		ids = append(ids, id)
	}
	return
}

// ResetActions resets all changes to the "actions" edge.
func (m *ProfileMutation) ResetActions() {
	m.actions = nil
	m.clearedactions = false
	m.removedactions = nil
}

// AddSquadIDs adds the "squad" edge to the Squad entity by ids.
func (m *ProfileMutation) AddSquadIDs(ids ...uuid.UUID) {
	if m.squad == nil {
		m.squad = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.squad[ids[i]] = struct{}{}
	}
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *ProfileMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *ProfileMutation) SquadCleared() bool {
	return m.clearedsquad
}

// RemoveSquadIDs removes the "squad" edge to the Squad entity by IDs.
func (m *ProfileMutation) RemoveSquadIDs(ids ...uuid.UUID) {
	if m.removedsquad == nil {
		m.removedsquad = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.squad, ids[i])
		m.removedsquad[ids[i]] = struct{}{}
	}
}

// RemovedSquad returns the removed IDs of the "squad" edge to the Squad entity.
func (m *ProfileMutation) RemovedSquadIDs() (ids []uuid.UUID) {
	for id := range m.removedsquad {
		ids = append(ids, id)
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
func (m *ProfileMutation) SquadIDs() (ids []uuid.UUID) {
	for id := range m.squad {
		ids = append(ids, id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *ProfileMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
	m.removedsquad = nil
}

// AddSquadsOwnedIDs adds the "squads_owned" edge to the Squad entity by ids.
func (m *ProfileMutation) AddSquadsOwnedIDs(ids ...uuid.UUID) {
	if m.squads_owned == nil {
		m.squads_owned = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.squads_owned[ids[i]] = struct{}{}
	}
}

// ClearSquadsOwned clears the "squads_owned" edge to the Squad entity.
func (m *ProfileMutation) ClearSquadsOwned() {
	m.clearedsquads_owned = true
}

// SquadsOwnedCleared reports if the "squads_owned" edge to the Squad entity was cleared.
func (m *ProfileMutation) SquadsOwnedCleared() bool {
	return m.clearedsquads_owned
}

// RemoveSquadsOwnedIDs removes the "squads_owned" edge to the Squad entity by IDs.
func (m *ProfileMutation) RemoveSquadsOwnedIDs(ids ...uuid.UUID) {
	if m.removedsquads_owned == nil {
		m.removedsquads_owned = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.squads_owned, ids[i])
		m.removedsquads_owned[ids[i]] = struct{}{}
	}
}

// RemovedSquadsOwned returns the removed IDs of the "squads_owned" edge to the Squad entity.
func (m *ProfileMutation) RemovedSquadsOwnedIDs() (ids []uuid.UUID) {
	for id := range m.removedsquads_owned {
		ids = append(ids, id)
	}
	return
}

// SquadsOwnedIDs returns the "squads_owned" edge IDs in the mutation.
func (m *ProfileMutation) SquadsOwnedIDs() (ids []uuid.UUID) {
	for id := range m.squads_owned {
		ids = append(ids, id)
	}
	return
}

// ResetSquadsOwned resets all changes to the "squads_owned" edge.
func (m *ProfileMutation) ResetSquadsOwned() {
	m.squads_owned = nil
	m.clearedsquads_owned = false
	m.removedsquads_owned = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *ProfileMutation) AddInviteIDs(ids ...uuid.UUID) {
	if m.invites == nil {
		m.invites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *ProfileMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *ProfileMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *ProfileMutation) RemoveInviteIDs(ids ...uuid.UUID) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *ProfileMutation) RemovedInvitesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *ProfileMutation) InvitesIDs() (ids []uuid.UUID) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *ProfileMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddInvitesSentIDs adds the "invites_sent" edge to the Invite entity by ids.
func (m *ProfileMutation) AddInvitesSentIDs(ids ...uuid.UUID) {
	if m.invites_sent == nil {
		m.invites_sent = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invites_sent[ids[i]] = struct{}{}
	}
}

// ClearInvitesSent clears the "invites_sent" edge to the Invite entity.
func (m *ProfileMutation) ClearInvitesSent() {
	m.clearedinvites_sent = true
}

// InvitesSentCleared reports if the "invites_sent" edge to the Invite entity was cleared.
func (m *ProfileMutation) InvitesSentCleared() bool {
	return m.clearedinvites_sent
}

// RemoveInvitesSentIDs removes the "invites_sent" edge to the Invite entity by IDs.
func (m *ProfileMutation) RemoveInvitesSentIDs(ids ...uuid.UUID) {
	if m.removedinvites_sent == nil {
		m.removedinvites_sent = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invites_sent, ids[i])
		m.removedinvites_sent[ids[i]] = struct{}{}
	}
}

// RemovedInvitesSent returns the removed IDs of the "invites_sent" edge to the Invite entity.
func (m *ProfileMutation) RemovedInvitesSentIDs() (ids []uuid.UUID) {
	for id := range m.removedinvites_sent {
		ids = append(ids, id)
	}
	return
}

// InvitesSentIDs returns the "invites_sent" edge IDs in the mutation.
func (m *ProfileMutation) InvitesSentIDs() (ids []uuid.UUID) {
	for id := range m.invites_sent {
		ids = append(ids, id)
	}
	return
}

// ResetInvitesSent resets all changes to the "invites_sent" edge.
func (m *ProfileMutation) ResetInvitesSent() {
	m.invites_sent = nil
	m.clearedinvites_sent = false
	m.removedinvites_sent = nil
}

// AddWorkoutIDs adds the "workouts" edge to the Workout entity by ids.
func (m *ProfileMutation) AddWorkoutIDs(ids ...uuid.UUID) {
	if m.workouts == nil {
		m.workouts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workouts[ids[i]] = struct{}{}
	}
}

// ClearWorkouts clears the "workouts" edge to the Workout entity.
func (m *ProfileMutation) ClearWorkouts() {
	m.clearedworkouts = true
}

// WorkoutsCleared reports if the "workouts" edge to the Workout entity was cleared.
func (m *ProfileMutation) WorkoutsCleared() bool {
	return m.clearedworkouts
}

// RemoveWorkoutIDs removes the "workouts" edge to the Workout entity by IDs.
func (m *ProfileMutation) RemoveWorkoutIDs(ids ...uuid.UUID) {
	if m.removedworkouts == nil {
		m.removedworkouts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workouts, ids[i])
		m.removedworkouts[ids[i]] = struct{}{}
	}
}

// RemovedWorkouts returns the removed IDs of the "workouts" edge to the Workout entity.
func (m *ProfileMutation) RemovedWorkoutsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkouts {
		ids = append(ids, id)
	}
	return
}

// WorkoutsIDs returns the "workouts" edge IDs in the mutation.
func (m *ProfileMutation) WorkoutsIDs() (ids []uuid.UUID) {
	for id := range m.workouts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkouts resets all changes to the "workouts" edge.
func (m *ProfileMutation) ResetWorkouts() {
	m.workouts = nil
	m.clearedworkouts = false
	m.removedworkouts = nil
}

// AddGoalIDs adds the "goals" edge to the Goal entity by ids.
func (m *ProfileMutation) AddGoalIDs(ids ...uuid.UUID) {
	if m.goals == nil {
		m.goals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.goals[ids[i]] = struct{}{}
	}
}

// ClearGoals clears the "goals" edge to the Goal entity.
func (m *ProfileMutation) ClearGoals() {
	m.clearedgoals = true
}

// GoalsCleared reports if the "goals" edge to the Goal entity was cleared.
func (m *ProfileMutation) GoalsCleared() bool {
	return m.clearedgoals
}

// RemoveGoalIDs removes the "goals" edge to the Goal entity by IDs.
func (m *ProfileMutation) RemoveGoalIDs(ids ...uuid.UUID) {
	if m.removedgoals == nil {
		m.removedgoals = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.goals, ids[i])
		m.removedgoals[ids[i]] = struct{}{}
	}
}

// RemovedGoals returns the removed IDs of the "goals" edge to the Goal entity.
func (m *ProfileMutation) RemovedGoalsIDs() (ids []uuid.UUID) {
	for id := range m.removedgoals {
		ids = append(ids, id)
	}
	return
}

// GoalsIDs returns the "goals" edge IDs in the mutation.
func (m *ProfileMutation) GoalsIDs() (ids []uuid.UUID) {
	for id := range m.goals {
		ids = append(ids, id)
	}
	return
}

// ResetGoals resets all changes to the "goals" edge.
func (m *ProfileMutation) ResetGoals() {
	m.goals = nil
	m.clearedgoals = false
	m.removedgoals = nil
}

// AddWorkoutDatumIDs adds the "workout_data" edge to the WorkoutData entity by ids.
func (m *ProfileMutation) AddWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.workout_data == nil {
		m.workout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workout_data[ids[i]] = struct{}{}
	}
}

// ClearWorkoutData clears the "workout_data" edge to the WorkoutData entity.
func (m *ProfileMutation) ClearWorkoutData() {
	m.clearedworkout_data = true
}

// WorkoutDataCleared reports if the "workout_data" edge to the WorkoutData entity was cleared.
func (m *ProfileMutation) WorkoutDataCleared() bool {
	return m.clearedworkout_data
}

// RemoveWorkoutDatumIDs removes the "workout_data" edge to the WorkoutData entity by IDs.
func (m *ProfileMutation) RemoveWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.removedworkout_data == nil {
		m.removedworkout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workout_data, ids[i])
		m.removedworkout_data[ids[i]] = struct{}{}
	}
}

// RemovedWorkoutData returns the removed IDs of the "workout_data" edge to the WorkoutData entity.
func (m *ProfileMutation) RemovedWorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.removedworkout_data {
		ids = append(ids, id)
	}
	return
}

// WorkoutDataIDs returns the "workout_data" edge IDs in the mutation.
func (m *ProfileMutation) WorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.workout_data {
		ids = append(ids, id)
	}
	return
}

// ResetWorkoutData resets all changes to the "workout_data" edge.
func (m *ProfileMutation) ResetWorkoutData() {
	m.workout_data = nil
	m.clearedworkout_data = false
	m.removedworkout_data = nil
}

// AddCompetitionResultIDs adds the "competition_results" edge to the CompetitionResult entity by ids.
func (m *ProfileMutation) AddCompetitionResultIDs(ids ...uuid.UUID) {
	if m.competition_results == nil {
		m.competition_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.competition_results[ids[i]] = struct{}{}
	}
}

// ClearCompetitionResults clears the "competition_results" edge to the CompetitionResult entity.
func (m *ProfileMutation) ClearCompetitionResults() {
	m.clearedcompetition_results = true
}

// CompetitionResultsCleared reports if the "competition_results" edge to the CompetitionResult entity was cleared.
func (m *ProfileMutation) CompetitionResultsCleared() bool {
	return m.clearedcompetition_results
}

// RemoveCompetitionResultIDs removes the "competition_results" edge to the CompetitionResult entity by IDs.
func (m *ProfileMutation) RemoveCompetitionResultIDs(ids ...uuid.UUID) {
	if m.removedcompetition_results == nil {
		m.removedcompetition_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.competition_results, ids[i])
		m.removedcompetition_results[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionResults returns the removed IDs of the "competition_results" edge to the CompetitionResult entity.
func (m *ProfileMutation) RemovedCompetitionResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedcompetition_results {
		ids = append(ids, id)
	}
	return
}

// CompetitionResultsIDs returns the "competition_results" edge IDs in the mutation.
func (m *ProfileMutation) CompetitionResultsIDs() (ids []uuid.UUID) {
	for id := range m.competition_results {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionResults resets all changes to the "competition_results" edge.
func (m *ProfileMutation) ResetCompetitionResults() {
	m.competition_results = nil
	m.clearedcompetition_results = false
	m.removedcompetition_results = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m.public != nil {
		fields = append(fields, profile.FieldPublic)
	}
	if m.first_name != nil {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, profile.FieldLastName)
	}
	if m.picture != nil {
		fields = append(fields, profile.FieldPicture)
	}
	if m.birthday != nil {
		fields = append(fields, profile.FieldBirthday)
	}
	if m.onboarding_completed != nil {
		fields = append(fields, profile.FieldOnboardingCompleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldPublic:
		return m.Public()
	case profile.FieldFirstName:
		return m.FirstName()
	case profile.FieldLastName:
		return m.LastName()
	case profile.FieldPicture:
		return m.Picture()
	case profile.FieldBirthday:
		return m.Birthday()
	case profile.FieldOnboardingCompleted:
		return m.OnboardingCompleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldPublic:
		return m.OldPublic(ctx)
	case profile.FieldFirstName:
		return m.OldFirstName(ctx)
	case profile.FieldLastName:
		return m.OldLastName(ctx)
	case profile.FieldPicture:
		return m.OldPicture(ctx)
	case profile.FieldBirthday:
		return m.OldBirthday(ctx)
	case profile.FieldOnboardingCompleted:
		return m.OldOnboardingCompleted(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case profile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case profile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case profile.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case profile.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case profile.FieldOnboardingCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingCompleted(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldPicture) {
		fields = append(fields, profile.FieldPicture)
	}
	if m.FieldCleared(profile.FieldBirthday) {
		fields = append(fields, profile.FieldBirthday)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldPicture:
		m.ClearPicture()
		return nil
	case profile.FieldBirthday:
		m.ClearBirthday()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldPublic:
		m.ResetPublic()
		return nil
	case profile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case profile.FieldLastName:
		m.ResetLastName()
		return nil
	case profile.FieldPicture:
		m.ResetPicture()
		return nil
	case profile.FieldBirthday:
		m.ResetBirthday()
		return nil
	case profile.FieldOnboardingCompleted:
		m.ResetOnboardingCompleted()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	if m.fcm_tokens != nil {
		edges = append(edges, profile.EdgeFcmTokens)
	}
	if m.notification_preferences != nil {
		edges = append(edges, profile.EdgeNotificationPreferences)
	}
	if m.app_config != nil {
		edges = append(edges, profile.EdgeAppConfig)
	}
	if m.notifications != nil {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.competitions != nil {
		edges = append(edges, profile.EdgeCompetitions)
	}
	if m.actions != nil {
		edges = append(edges, profile.EdgeActions)
	}
	if m.squad != nil {
		edges = append(edges, profile.EdgeSquad)
	}
	if m.squads_owned != nil {
		edges = append(edges, profile.EdgeSquadsOwned)
	}
	if m.invites != nil {
		edges = append(edges, profile.EdgeInvites)
	}
	if m.invites_sent != nil {
		edges = append(edges, profile.EdgeInvitesSent)
	}
	if m.workouts != nil {
		edges = append(edges, profile.EdgeWorkouts)
	}
	if m.goals != nil {
		edges = append(edges, profile.EdgeGoals)
	}
	if m.workout_data != nil {
		edges = append(edges, profile.EdgeWorkoutData)
	}
	if m.competition_results != nil {
		edges = append(edges, profile.EdgeCompetitionResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeFcmTokens:
		ids := make([]ent.Value, 0, len(m.fcm_tokens))
		for id := range m.fcm_tokens {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotificationPreferences:
		if id := m.notification_preferences; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeAppConfig:
		if id := m.app_config; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.competitions))
		for id := range m.competitions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeActions:
		ids := make([]ent.Value, 0, len(m.actions))
		for id := range m.actions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.squad))
		for id := range m.squad {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSquadsOwned:
		ids := make([]ent.Value, 0, len(m.squads_owned))
		for id := range m.squads_owned {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvitesSent:
		ids := make([]ent.Value, 0, len(m.invites_sent))
		for id := range m.invites_sent {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeWorkouts:
		ids := make([]ent.Value, 0, len(m.workouts))
		for id := range m.workouts {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.goals))
		for id := range m.goals {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.workout_data))
		for id := range m.workout_data {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCompetitionResults:
		ids := make([]ent.Value, 0, len(m.competition_results))
		for id := range m.competition_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedfcm_tokens != nil {
		edges = append(edges, profile.EdgeFcmTokens)
	}
	if m.removednotifications != nil {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.removedcompetitions != nil {
		edges = append(edges, profile.EdgeCompetitions)
	}
	if m.removedactions != nil {
		edges = append(edges, profile.EdgeActions)
	}
	if m.removedsquad != nil {
		edges = append(edges, profile.EdgeSquad)
	}
	if m.removedsquads_owned != nil {
		edges = append(edges, profile.EdgeSquadsOwned)
	}
	if m.removedinvites != nil {
		edges = append(edges, profile.EdgeInvites)
	}
	if m.removedinvites_sent != nil {
		edges = append(edges, profile.EdgeInvitesSent)
	}
	if m.removedworkouts != nil {
		edges = append(edges, profile.EdgeWorkouts)
	}
	if m.removedgoals != nil {
		edges = append(edges, profile.EdgeGoals)
	}
	if m.removedworkout_data != nil {
		edges = append(edges, profile.EdgeWorkoutData)
	}
	if m.removedcompetition_results != nil {
		edges = append(edges, profile.EdgeCompetitionResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeFcmTokens:
		ids := make([]ent.Value, 0, len(m.removedfcm_tokens))
		for id := range m.removedfcm_tokens {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCompetitions:
		ids := make([]ent.Value, 0, len(m.removedcompetitions))
		for id := range m.removedcompetitions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeActions:
		ids := make([]ent.Value, 0, len(m.removedactions))
		for id := range m.removedactions {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.removedsquad))
		for id := range m.removedsquad {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeSquadsOwned:
		ids := make([]ent.Value, 0, len(m.removedsquads_owned))
		for id := range m.removedsquads_owned {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeInvitesSent:
		ids := make([]ent.Value, 0, len(m.removedinvites_sent))
		for id := range m.removedinvites_sent {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeWorkouts:
		ids := make([]ent.Value, 0, len(m.removedworkouts))
		for id := range m.removedworkouts {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeGoals:
		ids := make([]ent.Value, 0, len(m.removedgoals))
		for id := range m.removedgoals {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.removedworkout_data))
		for id := range m.removedworkout_data {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeCompetitionResults:
		ids := make([]ent.Value, 0, len(m.removedcompetition_results))
		for id := range m.removedcompetition_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	if m.clearedfcm_tokens {
		edges = append(edges, profile.EdgeFcmTokens)
	}
	if m.clearednotification_preferences {
		edges = append(edges, profile.EdgeNotificationPreferences)
	}
	if m.clearedapp_config {
		edges = append(edges, profile.EdgeAppConfig)
	}
	if m.clearednotifications {
		edges = append(edges, profile.EdgeNotifications)
	}
	if m.clearedcompetitions {
		edges = append(edges, profile.EdgeCompetitions)
	}
	if m.clearedactions {
		edges = append(edges, profile.EdgeActions)
	}
	if m.clearedsquad {
		edges = append(edges, profile.EdgeSquad)
	}
	if m.clearedsquads_owned {
		edges = append(edges, profile.EdgeSquadsOwned)
	}
	if m.clearedinvites {
		edges = append(edges, profile.EdgeInvites)
	}
	if m.clearedinvites_sent {
		edges = append(edges, profile.EdgeInvitesSent)
	}
	if m.clearedworkouts {
		edges = append(edges, profile.EdgeWorkouts)
	}
	if m.clearedgoals {
		edges = append(edges, profile.EdgeGoals)
	}
	if m.clearedworkout_data {
		edges = append(edges, profile.EdgeWorkoutData)
	}
	if m.clearedcompetition_results {
		edges = append(edges, profile.EdgeCompetitionResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	case profile.EdgeFcmTokens:
		return m.clearedfcm_tokens
	case profile.EdgeNotificationPreferences:
		return m.clearednotification_preferences
	case profile.EdgeAppConfig:
		return m.clearedapp_config
	case profile.EdgeNotifications:
		return m.clearednotifications
	case profile.EdgeCompetitions:
		return m.clearedcompetitions
	case profile.EdgeActions:
		return m.clearedactions
	case profile.EdgeSquad:
		return m.clearedsquad
	case profile.EdgeSquadsOwned:
		return m.clearedsquads_owned
	case profile.EdgeInvites:
		return m.clearedinvites
	case profile.EdgeInvitesSent:
		return m.clearedinvites_sent
	case profile.EdgeWorkouts:
		return m.clearedworkouts
	case profile.EdgeGoals:
		return m.clearedgoals
	case profile.EdgeWorkoutData:
		return m.clearedworkout_data
	case profile.EdgeCompetitionResults:
		return m.clearedcompetition_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	case profile.EdgeNotificationPreferences:
		m.ClearNotificationPreferences()
		return nil
	case profile.EdgeAppConfig:
		m.ClearAppConfig()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	case profile.EdgeFcmTokens:
		m.ResetFcmTokens()
		return nil
	case profile.EdgeNotificationPreferences:
		m.ResetNotificationPreferences()
		return nil
	case profile.EdgeAppConfig:
		m.ResetAppConfig()
		return nil
	case profile.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case profile.EdgeCompetitions:
		m.ResetCompetitions()
		return nil
	case profile.EdgeActions:
		m.ResetActions()
		return nil
	case profile.EdgeSquad:
		m.ResetSquad()
		return nil
	case profile.EdgeSquadsOwned:
		m.ResetSquadsOwned()
		return nil
	case profile.EdgeInvites:
		m.ResetInvites()
		return nil
	case profile.EdgeInvitesSent:
		m.ResetInvitesSent()
		return nil
	case profile.EdgeWorkouts:
		m.ResetWorkouts()
		return nil
	case profile.EdgeGoals:
		m.ResetGoals()
		return nil
	case profile.EdgeWorkoutData:
		m.ResetWorkoutData()
		return nil
	case profile.EdgeCompetitionResults:
		m.ResetCompetitionResults()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// SquadMutation represents an operation that mutates the Squad nodes in the graph.
type SquadMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	public                     *bool
	title                      *string
	clearedFields              map[string]struct{}
	members                    map[uuid.UUID]struct{}
	removedmembers             map[uuid.UUID]struct{}
	clearedmembers             bool
	invites                    map[uuid.UUID]struct{}
	removedinvites             map[uuid.UUID]struct{}
	clearedinvites             bool
	competition_results        map[uuid.UUID]struct{}
	removedcompetition_results map[uuid.UUID]struct{}
	clearedcompetition_results bool
	owner                      *uuid.UUID
	clearedowner               bool
	done                       bool
	oldValue                   func(context.Context) (*Squad, error)
	predicates                 []predicate.Squad
}

var _ ent.Mutation = (*SquadMutation)(nil)

// squadOption allows management of the mutation configuration using functional options.
type squadOption func(*SquadMutation)

// newSquadMutation creates new mutation for the Squad entity.
func newSquadMutation(c config, op Op, opts ...squadOption) *SquadMutation {
	m := &SquadMutation{
		config:        c,
		op:            op,
		typ:           TypeSquad,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSquadID sets the ID field of the mutation.
func withSquadID(id uuid.UUID) squadOption {
	return func(m *SquadMutation) {
		var (
			err   error
			once  sync.Once
			value *Squad
		)
		m.oldValue = func(ctx context.Context) (*Squad, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Squad.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSquad sets the old Squad of the mutation.
func withSquad(node *Squad) squadOption {
	return func(m *SquadMutation) {
		m.oldValue = func(context.Context) (*Squad, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SquadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SquadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Squad entities.
func (m *SquadMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SquadMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SquadMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Squad.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SquadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SquadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SquadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SquadMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SquadMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SquadMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPublic sets the "public" field.
func (m *SquadMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *SquadMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *SquadMutation) ResetPublic() {
	m.public = nil
}

// SetTitle sets the "title" field.
func (m *SquadMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SquadMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SquadMutation) ResetTitle() {
	m.title = nil
}

// AddMemberIDs adds the "members" edge to the Profile entity by ids.
func (m *SquadMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Profile entity.
func (m *SquadMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Profile entity was cleared.
func (m *SquadMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Profile entity by IDs.
func (m *SquadMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Profile entity.
func (m *SquadMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *SquadMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *SquadMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddInviteIDs adds the "invites" edge to the Invite entity by ids.
func (m *SquadMutation) AddInviteIDs(ids ...uuid.UUID) {
	if m.invites == nil {
		m.invites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invites[ids[i]] = struct{}{}
	}
}

// ClearInvites clears the "invites" edge to the Invite entity.
func (m *SquadMutation) ClearInvites() {
	m.clearedinvites = true
}

// InvitesCleared reports if the "invites" edge to the Invite entity was cleared.
func (m *SquadMutation) InvitesCleared() bool {
	return m.clearedinvites
}

// RemoveInviteIDs removes the "invites" edge to the Invite entity by IDs.
func (m *SquadMutation) RemoveInviteIDs(ids ...uuid.UUID) {
	if m.removedinvites == nil {
		m.removedinvites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invites, ids[i])
		m.removedinvites[ids[i]] = struct{}{}
	}
}

// RemovedInvites returns the removed IDs of the "invites" edge to the Invite entity.
func (m *SquadMutation) RemovedInvitesIDs() (ids []uuid.UUID) {
	for id := range m.removedinvites {
		ids = append(ids, id)
	}
	return
}

// InvitesIDs returns the "invites" edge IDs in the mutation.
func (m *SquadMutation) InvitesIDs() (ids []uuid.UUID) {
	for id := range m.invites {
		ids = append(ids, id)
	}
	return
}

// ResetInvites resets all changes to the "invites" edge.
func (m *SquadMutation) ResetInvites() {
	m.invites = nil
	m.clearedinvites = false
	m.removedinvites = nil
}

// AddCompetitionResultIDs adds the "competition_results" edge to the CompetitionResult entity by ids.
func (m *SquadMutation) AddCompetitionResultIDs(ids ...uuid.UUID) {
	if m.competition_results == nil {
		m.competition_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.competition_results[ids[i]] = struct{}{}
	}
}

// ClearCompetitionResults clears the "competition_results" edge to the CompetitionResult entity.
func (m *SquadMutation) ClearCompetitionResults() {
	m.clearedcompetition_results = true
}

// CompetitionResultsCleared reports if the "competition_results" edge to the CompetitionResult entity was cleared.
func (m *SquadMutation) CompetitionResultsCleared() bool {
	return m.clearedcompetition_results
}

// RemoveCompetitionResultIDs removes the "competition_results" edge to the CompetitionResult entity by IDs.
func (m *SquadMutation) RemoveCompetitionResultIDs(ids ...uuid.UUID) {
	if m.removedcompetition_results == nil {
		m.removedcompetition_results = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.competition_results, ids[i])
		m.removedcompetition_results[ids[i]] = struct{}{}
	}
}

// RemovedCompetitionResults returns the removed IDs of the "competition_results" edge to the CompetitionResult entity.
func (m *SquadMutation) RemovedCompetitionResultsIDs() (ids []uuid.UUID) {
	for id := range m.removedcompetition_results {
		ids = append(ids, id)
	}
	return
}

// CompetitionResultsIDs returns the "competition_results" edge IDs in the mutation.
func (m *SquadMutation) CompetitionResultsIDs() (ids []uuid.UUID) {
	for id := range m.competition_results {
		ids = append(ids, id)
	}
	return
}

// ResetCompetitionResults resets all changes to the "competition_results" edge.
func (m *SquadMutation) ResetCompetitionResults() {
	m.competition_results = nil
	m.clearedcompetition_results = false
	m.removedcompetition_results = nil
}

// SetOwnerID sets the "owner" edge to the Profile entity by id.
func (m *SquadMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Profile entity.
func (m *SquadMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Profile entity was cleared.
func (m *SquadMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SquadMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SquadMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SquadMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SquadMutation builder.
func (m *SquadMutation) Where(ps ...predicate.Squad) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SquadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SquadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Squad, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SquadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SquadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Squad).
func (m *SquadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SquadMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, squad.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, squad.FieldUpdatedAt)
	}
	if m.public != nil {
		fields = append(fields, squad.FieldPublic)
	}
	if m.title != nil {
		fields = append(fields, squad.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SquadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case squad.FieldCreatedAt:
		return m.CreatedAt()
	case squad.FieldUpdatedAt:
		return m.UpdatedAt()
	case squad.FieldPublic:
		return m.Public()
	case squad.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SquadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case squad.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case squad.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case squad.FieldPublic:
		return m.OldPublic(ctx)
	case squad.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown Squad field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SquadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case squad.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case squad.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case squad.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case squad.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown Squad field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SquadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SquadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SquadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Squad numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SquadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SquadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SquadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Squad nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SquadMutation) ResetField(name string) error {
	switch name {
	case squad.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case squad.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case squad.FieldPublic:
		m.ResetPublic()
		return nil
	case squad.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown Squad field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SquadMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.members != nil {
		edges = append(edges, squad.EdgeMembers)
	}
	if m.invites != nil {
		edges = append(edges, squad.EdgeInvites)
	}
	if m.competition_results != nil {
		edges = append(edges, squad.EdgeCompetitionResults)
	}
	if m.owner != nil {
		edges = append(edges, squad.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SquadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case squad.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case squad.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.invites))
		for id := range m.invites {
			ids = append(ids, id)
		}
		return ids
	case squad.EdgeCompetitionResults:
		ids := make([]ent.Value, 0, len(m.competition_results))
		for id := range m.competition_results {
			ids = append(ids, id)
		}
		return ids
	case squad.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SquadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmembers != nil {
		edges = append(edges, squad.EdgeMembers)
	}
	if m.removedinvites != nil {
		edges = append(edges, squad.EdgeInvites)
	}
	if m.removedcompetition_results != nil {
		edges = append(edges, squad.EdgeCompetitionResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SquadMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case squad.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case squad.EdgeInvites:
		ids := make([]ent.Value, 0, len(m.removedinvites))
		for id := range m.removedinvites {
			ids = append(ids, id)
		}
		return ids
	case squad.EdgeCompetitionResults:
		ids := make([]ent.Value, 0, len(m.removedcompetition_results))
		for id := range m.removedcompetition_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SquadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmembers {
		edges = append(edges, squad.EdgeMembers)
	}
	if m.clearedinvites {
		edges = append(edges, squad.EdgeInvites)
	}
	if m.clearedcompetition_results {
		edges = append(edges, squad.EdgeCompetitionResults)
	}
	if m.clearedowner {
		edges = append(edges, squad.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SquadMutation) EdgeCleared(name string) bool {
	switch name {
	case squad.EdgeMembers:
		return m.clearedmembers
	case squad.EdgeInvites:
		return m.clearedinvites
	case squad.EdgeCompetitionResults:
		return m.clearedcompetition_results
	case squad.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SquadMutation) ClearEdge(name string) error {
	switch name {
	case squad.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Squad unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SquadMutation) ResetEdge(name string) error {
	switch name {
	case squad.EdgeMembers:
		m.ResetMembers()
		return nil
	case squad.EdgeInvites:
		m.ResetInvites()
		return nil
	case squad.EdgeCompetitionResults:
		m.ResetCompetitionResults()
		return nil
	case squad.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Squad edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	subject        *string
	clearedFields  map[string]struct{}
	profile        *uuid.UUID
	clearedprofile bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSubject sets the "subject" field.
func (m *UserMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *UserMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *UserMutation) ResetSubject() {
	m.subject = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.subject != nil {
		fields = append(fields, user.FieldSubject)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldSubject:
		return m.Subject()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldSubject:
		return m.OldSubject(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldSubject:
		m.ResetSubject()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfile:
		return m.clearedprofile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkoutMutation represents an operation that mutates the Workout nodes in the graph.
type WorkoutMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	healthkit_workout_activity_type *string
	clearedFields                   map[string]struct{}
	invite                          map[uuid.UUID]struct{}
	removedinvite                   map[uuid.UUID]struct{}
	clearedinvite                   bool
	leader                          *uuid.UUID
	clearedleader                   bool
	competition                     *uuid.UUID
	clearedcompetition              bool
	workout_data                    map[uuid.UUID]struct{}
	removedworkout_data             map[uuid.UUID]struct{}
	clearedworkout_data             bool
	workout_route_data              map[uuid.UUID]struct{}
	removedworkout_route_data       map[uuid.UUID]struct{}
	clearedworkout_route_data       bool
	done                            bool
	oldValue                        func(context.Context) (*Workout, error)
	predicates                      []predicate.Workout
}

var _ ent.Mutation = (*WorkoutMutation)(nil)

// workoutOption allows management of the mutation configuration using functional options.
type workoutOption func(*WorkoutMutation)

// newWorkoutMutation creates new mutation for the Workout entity.
func newWorkoutMutation(c config, op Op, opts ...workoutOption) *WorkoutMutation {
	m := &WorkoutMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkoutID sets the ID field of the mutation.
func withWorkoutID(id uuid.UUID) workoutOption {
	return func(m *WorkoutMutation) {
		var (
			err   error
			once  sync.Once
			value *Workout
		)
		m.oldValue = func(ctx context.Context) (*Workout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkout sets the old Workout of the mutation.
func withWorkout(node *Workout) workoutOption {
	return func(m *WorkoutMutation) {
		m.oldValue = func(context.Context) (*Workout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workout entities.
func (m *WorkoutMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkoutMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkoutMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkoutMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkoutMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workout entity.
// If the Workout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkoutMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkoutMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkoutMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workout entity.
// If the Workout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkoutMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHealthkitWorkoutActivityType sets the "healthkit_workout_activity_type" field.
func (m *WorkoutMutation) SetHealthkitWorkoutActivityType(s string) {
	m.healthkit_workout_activity_type = &s
}

// HealthkitWorkoutActivityType returns the value of the "healthkit_workout_activity_type" field in the mutation.
func (m *WorkoutMutation) HealthkitWorkoutActivityType() (r string, exists bool) {
	v := m.healthkit_workout_activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthkitWorkoutActivityType returns the old "healthkit_workout_activity_type" field's value of the Workout entity.
// If the Workout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutMutation) OldHealthkitWorkoutActivityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthkitWorkoutActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthkitWorkoutActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthkitWorkoutActivityType: %w", err)
	}
	return oldValue.HealthkitWorkoutActivityType, nil
}

// ResetHealthkitWorkoutActivityType resets all changes to the "healthkit_workout_activity_type" field.
func (m *WorkoutMutation) ResetHealthkitWorkoutActivityType() {
	m.healthkit_workout_activity_type = nil
}

// AddInviteIDs adds the "invite" edge to the Invite entity by ids.
func (m *WorkoutMutation) AddInviteIDs(ids ...uuid.UUID) {
	if m.invite == nil {
		m.invite = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invite[ids[i]] = struct{}{}
	}
}

// ClearInvite clears the "invite" edge to the Invite entity.
func (m *WorkoutMutation) ClearInvite() {
	m.clearedinvite = true
}

// InviteCleared reports if the "invite" edge to the Invite entity was cleared.
func (m *WorkoutMutation) InviteCleared() bool {
	return m.clearedinvite
}

// RemoveInviteIDs removes the "invite" edge to the Invite entity by IDs.
func (m *WorkoutMutation) RemoveInviteIDs(ids ...uuid.UUID) {
	if m.removedinvite == nil {
		m.removedinvite = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invite, ids[i])
		m.removedinvite[ids[i]] = struct{}{}
	}
}

// RemovedInvite returns the removed IDs of the "invite" edge to the Invite entity.
func (m *WorkoutMutation) RemovedInviteIDs() (ids []uuid.UUID) {
	for id := range m.removedinvite {
		ids = append(ids, id)
	}
	return
}

// InviteIDs returns the "invite" edge IDs in the mutation.
func (m *WorkoutMutation) InviteIDs() (ids []uuid.UUID) {
	for id := range m.invite {
		ids = append(ids, id)
	}
	return
}

// ResetInvite resets all changes to the "invite" edge.
func (m *WorkoutMutation) ResetInvite() {
	m.invite = nil
	m.clearedinvite = false
	m.removedinvite = nil
}

// SetLeaderID sets the "leader" edge to the Profile entity by id.
func (m *WorkoutMutation) SetLeaderID(id uuid.UUID) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the Profile entity.
func (m *WorkoutMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the Profile entity was cleared.
func (m *WorkoutMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *WorkoutMutation) LeaderID() (id uuid.UUID, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *WorkoutMutation) LeaderIDs() (ids []uuid.UUID) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *WorkoutMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// SetCompetitionID sets the "competition" edge to the Competition entity by id.
func (m *WorkoutMutation) SetCompetitionID(id uuid.UUID) {
	m.competition = &id
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *WorkoutMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *WorkoutMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionID returns the "competition" edge ID in the mutation.
func (m *WorkoutMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m.competition != nil {
		return *m.competition, true
	}
	return
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *WorkoutMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *WorkoutMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// AddWorkoutDatumIDs adds the "workout_data" edge to the WorkoutData entity by ids.
func (m *WorkoutMutation) AddWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.workout_data == nil {
		m.workout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workout_data[ids[i]] = struct{}{}
	}
}

// ClearWorkoutData clears the "workout_data" edge to the WorkoutData entity.
func (m *WorkoutMutation) ClearWorkoutData() {
	m.clearedworkout_data = true
}

// WorkoutDataCleared reports if the "workout_data" edge to the WorkoutData entity was cleared.
func (m *WorkoutMutation) WorkoutDataCleared() bool {
	return m.clearedworkout_data
}

// RemoveWorkoutDatumIDs removes the "workout_data" edge to the WorkoutData entity by IDs.
func (m *WorkoutMutation) RemoveWorkoutDatumIDs(ids ...uuid.UUID) {
	if m.removedworkout_data == nil {
		m.removedworkout_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workout_data, ids[i])
		m.removedworkout_data[ids[i]] = struct{}{}
	}
}

// RemovedWorkoutData returns the removed IDs of the "workout_data" edge to the WorkoutData entity.
func (m *WorkoutMutation) RemovedWorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.removedworkout_data {
		ids = append(ids, id)
	}
	return
}

// WorkoutDataIDs returns the "workout_data" edge IDs in the mutation.
func (m *WorkoutMutation) WorkoutDataIDs() (ids []uuid.UUID) {
	for id := range m.workout_data {
		ids = append(ids, id)
	}
	return
}

// ResetWorkoutData resets all changes to the "workout_data" edge.
func (m *WorkoutMutation) ResetWorkoutData() {
	m.workout_data = nil
	m.clearedworkout_data = false
	m.removedworkout_data = nil
}

// AddWorkoutRouteDatumIDs adds the "workout_route_data" edge to the WorkoutRouteData entity by ids.
func (m *WorkoutMutation) AddWorkoutRouteDatumIDs(ids ...uuid.UUID) {
	if m.workout_route_data == nil {
		m.workout_route_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workout_route_data[ids[i]] = struct{}{}
	}
}

// ClearWorkoutRouteData clears the "workout_route_data" edge to the WorkoutRouteData entity.
func (m *WorkoutMutation) ClearWorkoutRouteData() {
	m.clearedworkout_route_data = true
}

// WorkoutRouteDataCleared reports if the "workout_route_data" edge to the WorkoutRouteData entity was cleared.
func (m *WorkoutMutation) WorkoutRouteDataCleared() bool {
	return m.clearedworkout_route_data
}

// RemoveWorkoutRouteDatumIDs removes the "workout_route_data" edge to the WorkoutRouteData entity by IDs.
func (m *WorkoutMutation) RemoveWorkoutRouteDatumIDs(ids ...uuid.UUID) {
	if m.removedworkout_route_data == nil {
		m.removedworkout_route_data = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workout_route_data, ids[i])
		m.removedworkout_route_data[ids[i]] = struct{}{}
	}
}

// RemovedWorkoutRouteData returns the removed IDs of the "workout_route_data" edge to the WorkoutRouteData entity.
func (m *WorkoutMutation) RemovedWorkoutRouteDataIDs() (ids []uuid.UUID) {
	for id := range m.removedworkout_route_data {
		ids = append(ids, id)
	}
	return
}

// WorkoutRouteDataIDs returns the "workout_route_data" edge IDs in the mutation.
func (m *WorkoutMutation) WorkoutRouteDataIDs() (ids []uuid.UUID) {
	for id := range m.workout_route_data {
		ids = append(ids, id)
	}
	return
}

// ResetWorkoutRouteData resets all changes to the "workout_route_data" edge.
func (m *WorkoutMutation) ResetWorkoutRouteData() {
	m.workout_route_data = nil
	m.clearedworkout_route_data = false
	m.removedworkout_route_data = nil
}

// Where appends a list predicates to the WorkoutMutation builder.
func (m *WorkoutMutation) Where(ps ...predicate.Workout) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkoutMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkoutMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workout, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkoutMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkoutMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workout).
func (m *WorkoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkoutMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, workout.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workout.FieldUpdatedAt)
	}
	if m.healthkit_workout_activity_type != nil {
		fields = append(fields, workout.FieldHealthkitWorkoutActivityType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workout.FieldCreatedAt:
		return m.CreatedAt()
	case workout.FieldUpdatedAt:
		return m.UpdatedAt()
	case workout.FieldHealthkitWorkoutActivityType:
		return m.HealthkitWorkoutActivityType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workout.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workout.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workout.FieldHealthkitWorkoutActivityType:
		return m.OldHealthkitWorkoutActivityType(ctx)
	}
	return nil, fmt.Errorf("unknown Workout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workout.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workout.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workout.FieldHealthkitWorkoutActivityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthkitWorkoutActivityType(v)
		return nil
	}
	return fmt.Errorf("unknown Workout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkoutMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkoutMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkoutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkoutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Workout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkoutMutation) ResetField(name string) error {
	switch name {
	case workout.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workout.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workout.FieldHealthkitWorkoutActivityType:
		m.ResetHealthkitWorkoutActivityType()
		return nil
	}
	return fmt.Errorf("unknown Workout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.invite != nil {
		edges = append(edges, workout.EdgeInvite)
	}
	if m.leader != nil {
		edges = append(edges, workout.EdgeLeader)
	}
	if m.competition != nil {
		edges = append(edges, workout.EdgeCompetition)
	}
	if m.workout_data != nil {
		edges = append(edges, workout.EdgeWorkoutData)
	}
	if m.workout_route_data != nil {
		edges = append(edges, workout.EdgeWorkoutRouteData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workout.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.invite))
		for id := range m.invite {
			ids = append(ids, id)
		}
		return ids
	case workout.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case workout.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	case workout.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.workout_data))
		for id := range m.workout_data {
			ids = append(ids, id)
		}
		return ids
	case workout.EdgeWorkoutRouteData:
		ids := make([]ent.Value, 0, len(m.workout_route_data))
		for id := range m.workout_route_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedinvite != nil {
		edges = append(edges, workout.EdgeInvite)
	}
	if m.removedworkout_data != nil {
		edges = append(edges, workout.EdgeWorkoutData)
	}
	if m.removedworkout_route_data != nil {
		edges = append(edges, workout.EdgeWorkoutRouteData)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkoutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workout.EdgeInvite:
		ids := make([]ent.Value, 0, len(m.removedinvite))
		for id := range m.removedinvite {
			ids = append(ids, id)
		}
		return ids
	case workout.EdgeWorkoutData:
		ids := make([]ent.Value, 0, len(m.removedworkout_data))
		for id := range m.removedworkout_data {
			ids = append(ids, id)
		}
		return ids
	case workout.EdgeWorkoutRouteData:
		ids := make([]ent.Value, 0, len(m.removedworkout_route_data))
		for id := range m.removedworkout_route_data {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedinvite {
		edges = append(edges, workout.EdgeInvite)
	}
	if m.clearedleader {
		edges = append(edges, workout.EdgeLeader)
	}
	if m.clearedcompetition {
		edges = append(edges, workout.EdgeCompetition)
	}
	if m.clearedworkout_data {
		edges = append(edges, workout.EdgeWorkoutData)
	}
	if m.clearedworkout_route_data {
		edges = append(edges, workout.EdgeWorkoutRouteData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkoutMutation) EdgeCleared(name string) bool {
	switch name {
	case workout.EdgeInvite:
		return m.clearedinvite
	case workout.EdgeLeader:
		return m.clearedleader
	case workout.EdgeCompetition:
		return m.clearedcompetition
	case workout.EdgeWorkoutData:
		return m.clearedworkout_data
	case workout.EdgeWorkoutRouteData:
		return m.clearedworkout_route_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkoutMutation) ClearEdge(name string) error {
	switch name {
	case workout.EdgeLeader:
		m.ClearLeader()
		return nil
	case workout.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown Workout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkoutMutation) ResetEdge(name string) error {
	switch name {
	case workout.EdgeInvite:
		m.ResetInvite()
		return nil
	case workout.EdgeLeader:
		m.ResetLeader()
		return nil
	case workout.EdgeCompetition:
		m.ResetCompetition()
		return nil
	case workout.EdgeWorkoutData:
		m.ResetWorkoutData()
		return nil
	case workout.EdgeWorkoutRouteData:
		m.ResetWorkoutRouteData()
		return nil
	}
	return fmt.Errorf("unknown Workout edge %s", name)
}

// WorkoutDataMutation represents an operation that mutates the WorkoutData nodes in the graph.
type WorkoutDataMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	healthkit_workout_id         *string
	healthkit_workout_start_date *time.Time
	healthkit_workout_end_date   *time.Time
	distance                     *float64
	adddistance                  *float64
	duration                     *string
	energy_burned                *string
	average_heart_rate           *string
	source                       *string
	location_type                *string
	weather                      **shared.WorkoutDataWeather
	clearedFields                map[string]struct{}
	workout                      *uuid.UUID
	clearedworkout               bool
	profile                      *uuid.UUID
	clearedprofile               bool
	workout_route_data           *uuid.UUID
	clearedworkout_route_data    bool
	competition                  *uuid.UUID
	clearedcompetition           bool
	done                         bool
	oldValue                     func(context.Context) (*WorkoutData, error)
	predicates                   []predicate.WorkoutData
}

var _ ent.Mutation = (*WorkoutDataMutation)(nil)

// workoutdataOption allows management of the mutation configuration using functional options.
type workoutdataOption func(*WorkoutDataMutation)

// newWorkoutDataMutation creates new mutation for the WorkoutData entity.
func newWorkoutDataMutation(c config, op Op, opts ...workoutdataOption) *WorkoutDataMutation {
	m := &WorkoutDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkoutData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkoutDataID sets the ID field of the mutation.
func withWorkoutDataID(id uuid.UUID) workoutdataOption {
	return func(m *WorkoutDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkoutData
		)
		m.oldValue = func(ctx context.Context) (*WorkoutData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkoutData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkoutData sets the old WorkoutData of the mutation.
func withWorkoutData(node *WorkoutData) workoutdataOption {
	return func(m *WorkoutDataMutation) {
		m.oldValue = func(context.Context) (*WorkoutData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkoutDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkoutDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkoutData entities.
func (m *WorkoutDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkoutDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkoutDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkoutData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkoutDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkoutDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkoutDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkoutDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkoutDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkoutDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetHealthkitWorkoutID sets the "healthkit_workout_id" field.
func (m *WorkoutDataMutation) SetHealthkitWorkoutID(s string) {
	m.healthkit_workout_id = &s
}

// HealthkitWorkoutID returns the value of the "healthkit_workout_id" field in the mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutID() (r string, exists bool) {
	v := m.healthkit_workout_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthkitWorkoutID returns the old "healthkit_workout_id" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldHealthkitWorkoutID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthkitWorkoutID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthkitWorkoutID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthkitWorkoutID: %w", err)
	}
	return oldValue.HealthkitWorkoutID, nil
}

// ClearHealthkitWorkoutID clears the value of the "healthkit_workout_id" field.
func (m *WorkoutDataMutation) ClearHealthkitWorkoutID() {
	m.healthkit_workout_id = nil
	m.clearedFields[workoutdata.FieldHealthkitWorkoutID] = struct{}{}
}

// HealthkitWorkoutIDCleared returns if the "healthkit_workout_id" field was cleared in this mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutIDCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldHealthkitWorkoutID]
	return ok
}

// ResetHealthkitWorkoutID resets all changes to the "healthkit_workout_id" field.
func (m *WorkoutDataMutation) ResetHealthkitWorkoutID() {
	m.healthkit_workout_id = nil
	delete(m.clearedFields, workoutdata.FieldHealthkitWorkoutID)
}

// SetHealthkitWorkoutStartDate sets the "healthkit_workout_start_date" field.
func (m *WorkoutDataMutation) SetHealthkitWorkoutStartDate(t time.Time) {
	m.healthkit_workout_start_date = &t
}

// HealthkitWorkoutStartDate returns the value of the "healthkit_workout_start_date" field in the mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutStartDate() (r time.Time, exists bool) {
	v := m.healthkit_workout_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthkitWorkoutStartDate returns the old "healthkit_workout_start_date" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldHealthkitWorkoutStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthkitWorkoutStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthkitWorkoutStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthkitWorkoutStartDate: %w", err)
	}
	return oldValue.HealthkitWorkoutStartDate, nil
}

// ClearHealthkitWorkoutStartDate clears the value of the "healthkit_workout_start_date" field.
func (m *WorkoutDataMutation) ClearHealthkitWorkoutStartDate() {
	m.healthkit_workout_start_date = nil
	m.clearedFields[workoutdata.FieldHealthkitWorkoutStartDate] = struct{}{}
}

// HealthkitWorkoutStartDateCleared returns if the "healthkit_workout_start_date" field was cleared in this mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutStartDateCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldHealthkitWorkoutStartDate]
	return ok
}

// ResetHealthkitWorkoutStartDate resets all changes to the "healthkit_workout_start_date" field.
func (m *WorkoutDataMutation) ResetHealthkitWorkoutStartDate() {
	m.healthkit_workout_start_date = nil
	delete(m.clearedFields, workoutdata.FieldHealthkitWorkoutStartDate)
}

// SetHealthkitWorkoutEndDate sets the "healthkit_workout_end_date" field.
func (m *WorkoutDataMutation) SetHealthkitWorkoutEndDate(t time.Time) {
	m.healthkit_workout_end_date = &t
}

// HealthkitWorkoutEndDate returns the value of the "healthkit_workout_end_date" field in the mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutEndDate() (r time.Time, exists bool) {
	v := m.healthkit_workout_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthkitWorkoutEndDate returns the old "healthkit_workout_end_date" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldHealthkitWorkoutEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthkitWorkoutEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthkitWorkoutEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthkitWorkoutEndDate: %w", err)
	}
	return oldValue.HealthkitWorkoutEndDate, nil
}

// ClearHealthkitWorkoutEndDate clears the value of the "healthkit_workout_end_date" field.
func (m *WorkoutDataMutation) ClearHealthkitWorkoutEndDate() {
	m.healthkit_workout_end_date = nil
	m.clearedFields[workoutdata.FieldHealthkitWorkoutEndDate] = struct{}{}
}

// HealthkitWorkoutEndDateCleared returns if the "healthkit_workout_end_date" field was cleared in this mutation.
func (m *WorkoutDataMutation) HealthkitWorkoutEndDateCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldHealthkitWorkoutEndDate]
	return ok
}

// ResetHealthkitWorkoutEndDate resets all changes to the "healthkit_workout_end_date" field.
func (m *WorkoutDataMutation) ResetHealthkitWorkoutEndDate() {
	m.healthkit_workout_end_date = nil
	delete(m.clearedFields, workoutdata.FieldHealthkitWorkoutEndDate)
}

// SetDistance sets the "distance" field.
func (m *WorkoutDataMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *WorkoutDataMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldDistance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *WorkoutDataMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *WorkoutDataMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistance clears the value of the "distance" field.
func (m *WorkoutDataMutation) ClearDistance() {
	m.distance = nil
	m.adddistance = nil
	m.clearedFields[workoutdata.FieldDistance] = struct{}{}
}

// DistanceCleared returns if the "distance" field was cleared in this mutation.
func (m *WorkoutDataMutation) DistanceCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldDistance]
	return ok
}

// ResetDistance resets all changes to the "distance" field.
func (m *WorkoutDataMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
	delete(m.clearedFields, workoutdata.FieldDistance)
}

// SetDuration sets the "duration" field.
func (m *WorkoutDataMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *WorkoutDataMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *WorkoutDataMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[workoutdata.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *WorkoutDataMutation) DurationCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *WorkoutDataMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, workoutdata.FieldDuration)
}

// SetEnergyBurned sets the "energy_burned" field.
func (m *WorkoutDataMutation) SetEnergyBurned(s string) {
	m.energy_burned = &s
}

// EnergyBurned returns the value of the "energy_burned" field in the mutation.
func (m *WorkoutDataMutation) EnergyBurned() (r string, exists bool) {
	v := m.energy_burned
	if v == nil {
		return
	}
	return *v, true
}

// OldEnergyBurned returns the old "energy_burned" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldEnergyBurned(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnergyBurned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnergyBurned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnergyBurned: %w", err)
	}
	return oldValue.EnergyBurned, nil
}

// ClearEnergyBurned clears the value of the "energy_burned" field.
func (m *WorkoutDataMutation) ClearEnergyBurned() {
	m.energy_burned = nil
	m.clearedFields[workoutdata.FieldEnergyBurned] = struct{}{}
}

// EnergyBurnedCleared returns if the "energy_burned" field was cleared in this mutation.
func (m *WorkoutDataMutation) EnergyBurnedCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldEnergyBurned]
	return ok
}

// ResetEnergyBurned resets all changes to the "energy_burned" field.
func (m *WorkoutDataMutation) ResetEnergyBurned() {
	m.energy_burned = nil
	delete(m.clearedFields, workoutdata.FieldEnergyBurned)
}

// SetAverageHeartRate sets the "average_heart_rate" field.
func (m *WorkoutDataMutation) SetAverageHeartRate(s string) {
	m.average_heart_rate = &s
}

// AverageHeartRate returns the value of the "average_heart_rate" field in the mutation.
func (m *WorkoutDataMutation) AverageHeartRate() (r string, exists bool) {
	v := m.average_heart_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageHeartRate returns the old "average_heart_rate" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldAverageHeartRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageHeartRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageHeartRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageHeartRate: %w", err)
	}
	return oldValue.AverageHeartRate, nil
}

// ClearAverageHeartRate clears the value of the "average_heart_rate" field.
func (m *WorkoutDataMutation) ClearAverageHeartRate() {
	m.average_heart_rate = nil
	m.clearedFields[workoutdata.FieldAverageHeartRate] = struct{}{}
}

// AverageHeartRateCleared returns if the "average_heart_rate" field was cleared in this mutation.
func (m *WorkoutDataMutation) AverageHeartRateCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldAverageHeartRate]
	return ok
}

// ResetAverageHeartRate resets all changes to the "average_heart_rate" field.
func (m *WorkoutDataMutation) ResetAverageHeartRate() {
	m.average_heart_rate = nil
	delete(m.clearedFields, workoutdata.FieldAverageHeartRate)
}

// SetSource sets the "source" field.
func (m *WorkoutDataMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *WorkoutDataMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *WorkoutDataMutation) ResetSource() {
	m.source = nil
}

// SetLocationType sets the "location_type" field.
func (m *WorkoutDataMutation) SetLocationType(s string) {
	m.location_type = &s
}

// LocationType returns the value of the "location_type" field in the mutation.
func (m *WorkoutDataMutation) LocationType() (r string, exists bool) {
	v := m.location_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationType returns the old "location_type" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldLocationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationType: %w", err)
	}
	return oldValue.LocationType, nil
}

// ResetLocationType resets all changes to the "location_type" field.
func (m *WorkoutDataMutation) ResetLocationType() {
	m.location_type = nil
}

// SetWeather sets the "weather" field.
func (m *WorkoutDataMutation) SetWeather(sdw *shared.WorkoutDataWeather) {
	m.weather = &sdw
}

// Weather returns the value of the "weather" field in the mutation.
func (m *WorkoutDataMutation) Weather() (r *shared.WorkoutDataWeather, exists bool) {
	v := m.weather
	if v == nil {
		return
	}
	return *v, true
}

// OldWeather returns the old "weather" field's value of the WorkoutData entity.
// If the WorkoutData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutDataMutation) OldWeather(ctx context.Context) (v *shared.WorkoutDataWeather, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeather is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeather: %w", err)
	}
	return oldValue.Weather, nil
}

// ClearWeather clears the value of the "weather" field.
func (m *WorkoutDataMutation) ClearWeather() {
	m.weather = nil
	m.clearedFields[workoutdata.FieldWeather] = struct{}{}
}

// WeatherCleared returns if the "weather" field was cleared in this mutation.
func (m *WorkoutDataMutation) WeatherCleared() bool {
	_, ok := m.clearedFields[workoutdata.FieldWeather]
	return ok
}

// ResetWeather resets all changes to the "weather" field.
func (m *WorkoutDataMutation) ResetWeather() {
	m.weather = nil
	delete(m.clearedFields, workoutdata.FieldWeather)
}

// SetWorkoutID sets the "workout" edge to the Workout entity by id.
func (m *WorkoutDataMutation) SetWorkoutID(id uuid.UUID) {
	m.workout = &id
}

// ClearWorkout clears the "workout" edge to the Workout entity.
func (m *WorkoutDataMutation) ClearWorkout() {
	m.clearedworkout = true
}

// WorkoutCleared reports if the "workout" edge to the Workout entity was cleared.
func (m *WorkoutDataMutation) WorkoutCleared() bool {
	return m.clearedworkout
}

// WorkoutID returns the "workout" edge ID in the mutation.
func (m *WorkoutDataMutation) WorkoutID() (id uuid.UUID, exists bool) {
	if m.workout != nil {
		return *m.workout, true
	}
	return
}

// WorkoutIDs returns the "workout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkoutID instead. It exists only for internal usage by the builders.
func (m *WorkoutDataMutation) WorkoutIDs() (ids []uuid.UUID) {
	if id := m.workout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkout resets all changes to the "workout" edge.
func (m *WorkoutDataMutation) ResetWorkout() {
	m.workout = nil
	m.clearedworkout = false
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *WorkoutDataMutation) SetProfileID(id uuid.UUID) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *WorkoutDataMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *WorkoutDataMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *WorkoutDataMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *WorkoutDataMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *WorkoutDataMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// SetWorkoutRouteDataID sets the "workout_route_data" edge to the WorkoutRouteData entity by id.
func (m *WorkoutDataMutation) SetWorkoutRouteDataID(id uuid.UUID) {
	m.workout_route_data = &id
}

// ClearWorkoutRouteData clears the "workout_route_data" edge to the WorkoutRouteData entity.
func (m *WorkoutDataMutation) ClearWorkoutRouteData() {
	m.clearedworkout_route_data = true
}

// WorkoutRouteDataCleared reports if the "workout_route_data" edge to the WorkoutRouteData entity was cleared.
func (m *WorkoutDataMutation) WorkoutRouteDataCleared() bool {
	return m.clearedworkout_route_data
}

// WorkoutRouteDataID returns the "workout_route_data" edge ID in the mutation.
func (m *WorkoutDataMutation) WorkoutRouteDataID() (id uuid.UUID, exists bool) {
	if m.workout_route_data != nil {
		return *m.workout_route_data, true
	}
	return
}

// WorkoutRouteDataIDs returns the "workout_route_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkoutRouteDataID instead. It exists only for internal usage by the builders.
func (m *WorkoutDataMutation) WorkoutRouteDataIDs() (ids []uuid.UUID) {
	if id := m.workout_route_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkoutRouteData resets all changes to the "workout_route_data" edge.
func (m *WorkoutDataMutation) ResetWorkoutRouteData() {
	m.workout_route_data = nil
	m.clearedworkout_route_data = false
}

// SetCompetitionID sets the "competition" edge to the Competition entity by id.
func (m *WorkoutDataMutation) SetCompetitionID(id uuid.UUID) {
	m.competition = &id
}

// ClearCompetition clears the "competition" edge to the Competition entity.
func (m *WorkoutDataMutation) ClearCompetition() {
	m.clearedcompetition = true
}

// CompetitionCleared reports if the "competition" edge to the Competition entity was cleared.
func (m *WorkoutDataMutation) CompetitionCleared() bool {
	return m.clearedcompetition
}

// CompetitionID returns the "competition" edge ID in the mutation.
func (m *WorkoutDataMutation) CompetitionID() (id uuid.UUID, exists bool) {
	if m.competition != nil {
		return *m.competition, true
	}
	return
}

// CompetitionIDs returns the "competition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompetitionID instead. It exists only for internal usage by the builders.
func (m *WorkoutDataMutation) CompetitionIDs() (ids []uuid.UUID) {
	if id := m.competition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompetition resets all changes to the "competition" edge.
func (m *WorkoutDataMutation) ResetCompetition() {
	m.competition = nil
	m.clearedcompetition = false
}

// Where appends a list predicates to the WorkoutDataMutation builder.
func (m *WorkoutDataMutation) Where(ps ...predicate.WorkoutData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkoutDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkoutDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkoutData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkoutDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkoutDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkoutData).
func (m *WorkoutDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkoutDataMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, workoutdata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workoutdata.FieldUpdatedAt)
	}
	if m.healthkit_workout_id != nil {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutID)
	}
	if m.healthkit_workout_start_date != nil {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutStartDate)
	}
	if m.healthkit_workout_end_date != nil {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutEndDate)
	}
	if m.distance != nil {
		fields = append(fields, workoutdata.FieldDistance)
	}
	if m.duration != nil {
		fields = append(fields, workoutdata.FieldDuration)
	}
	if m.energy_burned != nil {
		fields = append(fields, workoutdata.FieldEnergyBurned)
	}
	if m.average_heart_rate != nil {
		fields = append(fields, workoutdata.FieldAverageHeartRate)
	}
	if m.source != nil {
		fields = append(fields, workoutdata.FieldSource)
	}
	if m.location_type != nil {
		fields = append(fields, workoutdata.FieldLocationType)
	}
	if m.weather != nil {
		fields = append(fields, workoutdata.FieldWeather)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkoutDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workoutdata.FieldCreatedAt:
		return m.CreatedAt()
	case workoutdata.FieldUpdatedAt:
		return m.UpdatedAt()
	case workoutdata.FieldHealthkitWorkoutID:
		return m.HealthkitWorkoutID()
	case workoutdata.FieldHealthkitWorkoutStartDate:
		return m.HealthkitWorkoutStartDate()
	case workoutdata.FieldHealthkitWorkoutEndDate:
		return m.HealthkitWorkoutEndDate()
	case workoutdata.FieldDistance:
		return m.Distance()
	case workoutdata.FieldDuration:
		return m.Duration()
	case workoutdata.FieldEnergyBurned:
		return m.EnergyBurned()
	case workoutdata.FieldAverageHeartRate:
		return m.AverageHeartRate()
	case workoutdata.FieldSource:
		return m.Source()
	case workoutdata.FieldLocationType:
		return m.LocationType()
	case workoutdata.FieldWeather:
		return m.Weather()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkoutDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workoutdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workoutdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workoutdata.FieldHealthkitWorkoutID:
		return m.OldHealthkitWorkoutID(ctx)
	case workoutdata.FieldHealthkitWorkoutStartDate:
		return m.OldHealthkitWorkoutStartDate(ctx)
	case workoutdata.FieldHealthkitWorkoutEndDate:
		return m.OldHealthkitWorkoutEndDate(ctx)
	case workoutdata.FieldDistance:
		return m.OldDistance(ctx)
	case workoutdata.FieldDuration:
		return m.OldDuration(ctx)
	case workoutdata.FieldEnergyBurned:
		return m.OldEnergyBurned(ctx)
	case workoutdata.FieldAverageHeartRate:
		return m.OldAverageHeartRate(ctx)
	case workoutdata.FieldSource:
		return m.OldSource(ctx)
	case workoutdata.FieldLocationType:
		return m.OldLocationType(ctx)
	case workoutdata.FieldWeather:
		return m.OldWeather(ctx)
	}
	return nil, fmt.Errorf("unknown WorkoutData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workoutdata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workoutdata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workoutdata.FieldHealthkitWorkoutID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthkitWorkoutID(v)
		return nil
	case workoutdata.FieldHealthkitWorkoutStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthkitWorkoutStartDate(v)
		return nil
	case workoutdata.FieldHealthkitWorkoutEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthkitWorkoutEndDate(v)
		return nil
	case workoutdata.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	case workoutdata.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case workoutdata.FieldEnergyBurned:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnergyBurned(v)
		return nil
	case workoutdata.FieldAverageHeartRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageHeartRate(v)
		return nil
	case workoutdata.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case workoutdata.FieldLocationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationType(v)
		return nil
	case workoutdata.FieldWeather:
		v, ok := value.(*shared.WorkoutDataWeather)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeather(v)
		return nil
	}
	return fmt.Errorf("unknown WorkoutData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkoutDataMutation) AddedFields() []string {
	var fields []string
	if m.adddistance != nil {
		fields = append(fields, workoutdata.FieldDistance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkoutDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workoutdata.FieldDistance:
		return m.AddedDistance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workoutdata.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	}
	return fmt.Errorf("unknown WorkoutData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkoutDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workoutdata.FieldHealthkitWorkoutID) {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutID)
	}
	if m.FieldCleared(workoutdata.FieldHealthkitWorkoutStartDate) {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutStartDate)
	}
	if m.FieldCleared(workoutdata.FieldHealthkitWorkoutEndDate) {
		fields = append(fields, workoutdata.FieldHealthkitWorkoutEndDate)
	}
	if m.FieldCleared(workoutdata.FieldDistance) {
		fields = append(fields, workoutdata.FieldDistance)
	}
	if m.FieldCleared(workoutdata.FieldDuration) {
		fields = append(fields, workoutdata.FieldDuration)
	}
	if m.FieldCleared(workoutdata.FieldEnergyBurned) {
		fields = append(fields, workoutdata.FieldEnergyBurned)
	}
	if m.FieldCleared(workoutdata.FieldAverageHeartRate) {
		fields = append(fields, workoutdata.FieldAverageHeartRate)
	}
	if m.FieldCleared(workoutdata.FieldWeather) {
		fields = append(fields, workoutdata.FieldWeather)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkoutDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkoutDataMutation) ClearField(name string) error {
	switch name {
	case workoutdata.FieldHealthkitWorkoutID:
		m.ClearHealthkitWorkoutID()
		return nil
	case workoutdata.FieldHealthkitWorkoutStartDate:
		m.ClearHealthkitWorkoutStartDate()
		return nil
	case workoutdata.FieldHealthkitWorkoutEndDate:
		m.ClearHealthkitWorkoutEndDate()
		return nil
	case workoutdata.FieldDistance:
		m.ClearDistance()
		return nil
	case workoutdata.FieldDuration:
		m.ClearDuration()
		return nil
	case workoutdata.FieldEnergyBurned:
		m.ClearEnergyBurned()
		return nil
	case workoutdata.FieldAverageHeartRate:
		m.ClearAverageHeartRate()
		return nil
	case workoutdata.FieldWeather:
		m.ClearWeather()
		return nil
	}
	return fmt.Errorf("unknown WorkoutData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkoutDataMutation) ResetField(name string) error {
	switch name {
	case workoutdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workoutdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workoutdata.FieldHealthkitWorkoutID:
		m.ResetHealthkitWorkoutID()
		return nil
	case workoutdata.FieldHealthkitWorkoutStartDate:
		m.ResetHealthkitWorkoutStartDate()
		return nil
	case workoutdata.FieldHealthkitWorkoutEndDate:
		m.ResetHealthkitWorkoutEndDate()
		return nil
	case workoutdata.FieldDistance:
		m.ResetDistance()
		return nil
	case workoutdata.FieldDuration:
		m.ResetDuration()
		return nil
	case workoutdata.FieldEnergyBurned:
		m.ResetEnergyBurned()
		return nil
	case workoutdata.FieldAverageHeartRate:
		m.ResetAverageHeartRate()
		return nil
	case workoutdata.FieldSource:
		m.ResetSource()
		return nil
	case workoutdata.FieldLocationType:
		m.ResetLocationType()
		return nil
	case workoutdata.FieldWeather:
		m.ResetWeather()
		return nil
	}
	return fmt.Errorf("unknown WorkoutData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkoutDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workout != nil {
		edges = append(edges, workoutdata.EdgeWorkout)
	}
	if m.profile != nil {
		edges = append(edges, workoutdata.EdgeProfile)
	}
	if m.workout_route_data != nil {
		edges = append(edges, workoutdata.EdgeWorkoutRouteData)
	}
	if m.competition != nil {
		edges = append(edges, workoutdata.EdgeCompetition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkoutDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workoutdata.EdgeWorkout:
		if id := m.workout; id != nil {
			return []ent.Value{*id}
		}
	case workoutdata.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case workoutdata.EdgeWorkoutRouteData:
		if id := m.workout_route_data; id != nil {
			return []ent.Value{*id}
		}
	case workoutdata.EdgeCompetition:
		if id := m.competition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkoutDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkoutDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkoutDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkout {
		edges = append(edges, workoutdata.EdgeWorkout)
	}
	if m.clearedprofile {
		edges = append(edges, workoutdata.EdgeProfile)
	}
	if m.clearedworkout_route_data {
		edges = append(edges, workoutdata.EdgeWorkoutRouteData)
	}
	if m.clearedcompetition {
		edges = append(edges, workoutdata.EdgeCompetition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkoutDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workoutdata.EdgeWorkout:
		return m.clearedworkout
	case workoutdata.EdgeProfile:
		return m.clearedprofile
	case workoutdata.EdgeWorkoutRouteData:
		return m.clearedworkout_route_data
	case workoutdata.EdgeCompetition:
		return m.clearedcompetition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkoutDataMutation) ClearEdge(name string) error {
	switch name {
	case workoutdata.EdgeWorkout:
		m.ClearWorkout()
		return nil
	case workoutdata.EdgeProfile:
		m.ClearProfile()
		return nil
	case workoutdata.EdgeWorkoutRouteData:
		m.ClearWorkoutRouteData()
		return nil
	case workoutdata.EdgeCompetition:
		m.ClearCompetition()
		return nil
	}
	return fmt.Errorf("unknown WorkoutData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkoutDataMutation) ResetEdge(name string) error {
	switch name {
	case workoutdata.EdgeWorkout:
		m.ResetWorkout()
		return nil
	case workoutdata.EdgeProfile:
		m.ResetProfile()
		return nil
	case workoutdata.EdgeWorkoutRouteData:
		m.ResetWorkoutRouteData()
		return nil
	case workoutdata.EdgeCompetition:
		m.ResetCompetition()
		return nil
	}
	return fmt.Errorf("unknown WorkoutData edge %s", name)
}

// WorkoutRouteDataMutation represents an operation that mutates the WorkoutRouteData nodes in the graph.
type WorkoutRouteDataMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	workout             *uuid.UUID
	clearedworkout      bool
	workout_data        *uuid.UUID
	clearedworkout_data bool
	done                bool
	oldValue            func(context.Context) (*WorkoutRouteData, error)
	predicates          []predicate.WorkoutRouteData
}

var _ ent.Mutation = (*WorkoutRouteDataMutation)(nil)

// workoutroutedataOption allows management of the mutation configuration using functional options.
type workoutroutedataOption func(*WorkoutRouteDataMutation)

// newWorkoutRouteDataMutation creates new mutation for the WorkoutRouteData entity.
func newWorkoutRouteDataMutation(c config, op Op, opts ...workoutroutedataOption) *WorkoutRouteDataMutation {
	m := &WorkoutRouteDataMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkoutRouteData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkoutRouteDataID sets the ID field of the mutation.
func withWorkoutRouteDataID(id uuid.UUID) workoutroutedataOption {
	return func(m *WorkoutRouteDataMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkoutRouteData
		)
		m.oldValue = func(ctx context.Context) (*WorkoutRouteData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkoutRouteData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkoutRouteData sets the old WorkoutRouteData of the mutation.
func withWorkoutRouteData(node *WorkoutRouteData) workoutroutedataOption {
	return func(m *WorkoutRouteDataMutation) {
		m.oldValue = func(context.Context) (*WorkoutRouteData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkoutRouteDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkoutRouteDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkoutRouteData entities.
func (m *WorkoutRouteDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkoutRouteDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkoutRouteDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkoutRouteData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkoutRouteDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkoutRouteDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkoutRouteData entity.
// If the WorkoutRouteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutRouteDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkoutRouteDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkoutRouteDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkoutRouteDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkoutRouteData entity.
// If the WorkoutRouteData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkoutRouteDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkoutRouteDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkoutID sets the "workout" edge to the Workout entity by id.
func (m *WorkoutRouteDataMutation) SetWorkoutID(id uuid.UUID) {
	m.workout = &id
}

// ClearWorkout clears the "workout" edge to the Workout entity.
func (m *WorkoutRouteDataMutation) ClearWorkout() {
	m.clearedworkout = true
}

// WorkoutCleared reports if the "workout" edge to the Workout entity was cleared.
func (m *WorkoutRouteDataMutation) WorkoutCleared() bool {
	return m.clearedworkout
}

// WorkoutID returns the "workout" edge ID in the mutation.
func (m *WorkoutRouteDataMutation) WorkoutID() (id uuid.UUID, exists bool) {
	if m.workout != nil {
		return *m.workout, true
	}
	return
}

// WorkoutIDs returns the "workout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkoutID instead. It exists only for internal usage by the builders.
func (m *WorkoutRouteDataMutation) WorkoutIDs() (ids []uuid.UUID) {
	if id := m.workout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkout resets all changes to the "workout" edge.
func (m *WorkoutRouteDataMutation) ResetWorkout() {
	m.workout = nil
	m.clearedworkout = false
}

// SetWorkoutDataID sets the "workout_data" edge to the WorkoutData entity by id.
func (m *WorkoutRouteDataMutation) SetWorkoutDataID(id uuid.UUID) {
	m.workout_data = &id
}

// ClearWorkoutData clears the "workout_data" edge to the WorkoutData entity.
func (m *WorkoutRouteDataMutation) ClearWorkoutData() {
	m.clearedworkout_data = true
}

// WorkoutDataCleared reports if the "workout_data" edge to the WorkoutData entity was cleared.
func (m *WorkoutRouteDataMutation) WorkoutDataCleared() bool {
	return m.clearedworkout_data
}

// WorkoutDataID returns the "workout_data" edge ID in the mutation.
func (m *WorkoutRouteDataMutation) WorkoutDataID() (id uuid.UUID, exists bool) {
	if m.workout_data != nil {
		return *m.workout_data, true
	}
	return
}

// WorkoutDataIDs returns the "workout_data" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkoutDataID instead. It exists only for internal usage by the builders.
func (m *WorkoutRouteDataMutation) WorkoutDataIDs() (ids []uuid.UUID) {
	if id := m.workout_data; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkoutData resets all changes to the "workout_data" edge.
func (m *WorkoutRouteDataMutation) ResetWorkoutData() {
	m.workout_data = nil
	m.clearedworkout_data = false
}

// Where appends a list predicates to the WorkoutRouteDataMutation builder.
func (m *WorkoutRouteDataMutation) Where(ps ...predicate.WorkoutRouteData) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkoutRouteDataMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkoutRouteDataMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkoutRouteData, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkoutRouteDataMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkoutRouteDataMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkoutRouteData).
func (m *WorkoutRouteDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkoutRouteDataMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, workoutroutedata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workoutroutedata.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkoutRouteDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workoutroutedata.FieldCreatedAt:
		return m.CreatedAt()
	case workoutroutedata.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkoutRouteDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workoutroutedata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workoutroutedata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkoutRouteData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutRouteDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workoutroutedata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workoutroutedata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkoutRouteData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkoutRouteDataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkoutRouteDataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkoutRouteDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkoutRouteData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkoutRouteDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkoutRouteDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkoutRouteDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkoutRouteData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkoutRouteDataMutation) ResetField(name string) error {
	switch name {
	case workoutroutedata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workoutroutedata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkoutRouteData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkoutRouteDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workout != nil {
		edges = append(edges, workoutroutedata.EdgeWorkout)
	}
	if m.workout_data != nil {
		edges = append(edges, workoutroutedata.EdgeWorkoutData)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkoutRouteDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workoutroutedata.EdgeWorkout:
		if id := m.workout; id != nil {
			return []ent.Value{*id}
		}
	case workoutroutedata.EdgeWorkoutData:
		if id := m.workout_data; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkoutRouteDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkoutRouteDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkoutRouteDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkout {
		edges = append(edges, workoutroutedata.EdgeWorkout)
	}
	if m.clearedworkout_data {
		edges = append(edges, workoutroutedata.EdgeWorkoutData)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkoutRouteDataMutation) EdgeCleared(name string) bool {
	switch name {
	case workoutroutedata.EdgeWorkout:
		return m.clearedworkout
	case workoutroutedata.EdgeWorkoutData:
		return m.clearedworkout_data
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkoutRouteDataMutation) ClearEdge(name string) error {
	switch name {
	case workoutroutedata.EdgeWorkout:
		m.ClearWorkout()
		return nil
	case workoutroutedata.EdgeWorkoutData:
		m.ClearWorkoutData()
		return nil
	}
	return fmt.Errorf("unknown WorkoutRouteData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkoutRouteDataMutation) ResetEdge(name string) error {
	switch name {
	case workoutroutedata.EdgeWorkout:
		m.ResetWorkout()
		return nil
	case workoutroutedata.EdgeWorkoutData:
		m.ResetWorkoutData()
		return nil
	}
	return fmt.Errorf("unknown WorkoutRouteData edge %s", name)
}
